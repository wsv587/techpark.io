<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">

    

    

    <title>一份走心的runloop源码分析 | 技术线博客</title>
    <meta name="author" content="wsv587">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content="前言对iOS开发者而言，runloop是一个老生常谈的话题，但凡是iOS开发者，在工作中必然直接或间接的接触过runloop。而对于面试者而言，runloop又几乎是必考点。在几年前，笔者写过一篇文章NSRunLoop，对runloop原理以及应用场景做了基本介绍。但是当时也是道听途说，简单的翻看了源码的do…while循环，并没有深入源码。所以，本文将从源码的角度剖析runloop的组成，强化自己对runloop的认识，验证我们脑海中一直以来似懂非懂的原理，真心希望这篇文章能够帮助到大家...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="技术线博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">技术线博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/iOS">
                <span class="nav-text">iOS</span>
            </a>
        
            <a class="nav-item" href="/categories/front-end">
                <span class="nav-text">前端</span>
            </a>
        
            <a class="nav-item" href="/categories/back-end">
                <span class="nav-text">后端</span>
            </a>
        
            <a class="nav-item" href="/categories/leader">
                <span class="nav-text">领导</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么是runLoop"><span class="toc-number">2.</span> <span class="toc-text">为什么是runLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无处不在的runLoop"><span class="toc-number">3.</span> <span class="toc-text">无处不在的runLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runLoop-结构"><span class="toc-number">4.</span> <span class="toc-text">runLoop 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop结构体定义"><span class="toc-number">4.1.</span> <span class="toc-text">RunLoop结构体定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop提供的主要API"><span class="toc-number">4.2.</span> <span class="toc-text">RunLoop提供的主要API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop与线程关系"><span class="toc-number">5.</span> <span class="toc-text">RunLoop与线程关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取主线程的runloop"><span class="toc-number">5.1.</span> <span class="toc-text">获取主线程的runloop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取子线程的runloop"><span class="toc-number">5.2.</span> <span class="toc-text">获取子线程的runloop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopGet0-函数源码"><span class="toc-number">5.3.</span> <span class="toc-text">_CFRunLoopGet0()函数源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CFRunLoopMode"><span class="toc-number">6.</span> <span class="toc-text">CFRunLoopMode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mode结构体定义"><span class="toc-number">6.1.</span> <span class="toc-text">Mode结构体定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加commonMode源码"><span class="toc-number">6.2.</span> <span class="toc-text">添加commonMode源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CFRunLoopSource"><span class="toc-number">7.</span> <span class="toc-text">CFRunLoopSource</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Source0和Source1区别"><span class="toc-number">7.1.</span> <span class="toc-text">Source0和Source1区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加Source的源码"><span class="toc-number">7.2.</span> <span class="toc-text">添加Source的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIButton点击事件是source0还是source1？"><span class="toc-number">7.3.</span> <span class="toc-text">UIButton点击事件是source0还是source1？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop-timer"><span class="toc-number">8.</span> <span class="toc-text">RunLoop timer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopTimer结构体"><span class="toc-number">8.1.</span> <span class="toc-text">CFRunLoopTimer结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加timer的源码"><span class="toc-number">8.2.</span> <span class="toc-text">添加timer的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置timer下次触发时间的源码"><span class="toc-number">8.3.</span> <span class="toc-text">设置timer下次触发时间的源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop-observer"><span class="toc-number">9.</span> <span class="toc-text">RunLoop observer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopObserver结构体定义"><span class="toc-number">9.0.1.</span> <span class="toc-text">CFRunLoopObserver结构体定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加Observer源码"><span class="toc-number">9.1.</span> <span class="toc-text">添加Observer源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义Observer来监听runloop状态变化"><span class="toc-number">9.2.</span> <span class="toc-text">自定义Observer来监听runloop状态变化</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop运行相关源码"><span class="toc-number">10.</span> <span class="toc-text">RunLoop运行相关源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopRun源码"><span class="toc-number">10.1.</span> <span class="toc-text">CFRunLoopRun源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopRunInMode源码"><span class="toc-number">10.2.</span> <span class="toc-text">CFRunLoopRunInMode源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopRunSpecific源码"><span class="toc-number">10.3.</span> <span class="toc-text">CFRunLoopRunSpecific源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoopRun源码-1"><span class="toc-number">10.4.</span> <span class="toc-text">__CFRunLoopRun源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手动唤醒runloop的方式"><span class="toc-number">10.5.</span> <span class="toc-text">手动唤醒runloop的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手动唤醒runloop的代码"><span class="toc-number">10.6.</span> <span class="toc-text">手动唤醒runloop的代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GCD和RunLoop的关系"><span class="toc-number">11.</span> <span class="toc-text">GCD和RunLoop的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AutoreleasePool和RunLoop的关系"><span class="toc-number">12.</span> <span class="toc-text">AutoreleasePool和RunLoop的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop应用"><span class="toc-number">13.</span> <span class="toc-text">RunLoop应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#苹果对runloop的使用"><span class="toc-number">13.1.</span> <span class="toc-text">苹果对runloop的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFNetworking对runloop的使用"><span class="toc-number">13.2.</span> <span class="toc-text">AFNetworking对runloop的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDWebImage对runloop的使用"><span class="toc-number">13.3.</span> <span class="toc-text">SDWebImage对runloop的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Native对runloop的使用"><span class="toc-number">13.4.</span> <span class="toc-text">React Native对runloop的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章"><span class="toc-number">15.</span> <span class="toc-text">参考文章</span></a></li>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            一份走心的runloop源码分析
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://yoursite.com/2020/05/23/一份走心的runloop源码分析/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-23T11:32:08.000Z" itemprop="datePublished">2020-05-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/iOS/">iOS</a>, <a class="article-tag-link" href="/tags/runloop/">runloop</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对iOS开发者而言，runloop是一个老生常谈的话题，但凡是iOS开发者，在工作中必然直接或间接的接触过runloop。而对于面试者而言，runloop又几乎是必考点。在几年前，笔者写过一篇文章<a href="https://www.cnblogs.com/wsnb/p/4753685.html" target="_blank" rel="noopener">NSRunLoop</a>，对runloop原理以及应用场景做了基本介绍。但是当时也是道听途说，简单的翻看了源码的do…while循环，并没有深入源码。所以，本文将从源码的角度剖析runloop的组成，强化自己对runloop的认识，验证我们脑海中一直以来似懂非懂的原理，真心希望这篇文章能够帮助到大家。</p>
<blockquote>
<p>注意：为了减少篇幅、避免困惑，本篇文章贴出的源码稍有精简，比如去除了lock和windows的代码。</p>
</blockquote>
<h1 id="为什么是runLoop"><a href="#为什么是runLoop" class="headerlink" title="为什么是runLoop"></a>为什么是runLoop</h1><p>runloop顾名思义就是”跑圈“，所谓跑圈就给人一种循环的感觉。runloop运行的核心代码就是一个有状态的do…while循环。每循环一次就相当于跑了一圈，线程就会对当前这一圈里面产生的事件进行处理。那么为什么线程要有runloop呢？其实我们的APP可以理解为是靠event驱动的（包括iOS和Android应用）。我们触摸屏幕、网络回调等都是一个个的event，也就是事件。这些事件产生之后会分发给我们的APP，APP接收到事件之后分发给对应的线程。通常情况下，如果线程没有runloop，那么一个线程一次只能执行一个任务，执行完成后线程就会退出。要想APP的线程一直能够处理事件或者等待事件（比如异步事件），就要保活线程，也就是不能让线程早早的退出，此时runloop就派上用场了。我们已经说了，runloop本质上就是一个有状态的do…while循环，所以只要不是超时或者故意退出状态，那么runLoop就会一直执行do…while，所以可以保证线程不退出。其实也不是必须要给线程指定一个runloop，如果需要我们线程能够持续的处理事件，那么就需要给线程绑定一个runloop。也就是说，runloop能够保证线程一直可以一直处理事件。所以runloop的作用可以理解为：</p>
<ul>
<li>使程序一直运行并处理各种事件。这些事件包括但不限于用户操作、定时器任务、内核消息</li>
<li>有顺序的处理各种Event。因为runLoop有状态，可以决定线程在什么时候处理什么事件</li>
<li>节省CPU资源。通常情况下，事件并不是永无休止的产生，所以也就没必要让线程永无休止的运行。runloop可以在无事件处理时进入休眠状态，避免无休止的do…while跑空圈。</li>
</ul>
<p>不得不重复那句老生常谈的话：一个线程对应一个RunLoop，程序运行是主线程的RunLoop默认启动，子线程的RunLoop按需启动（调用run方法）。runloop是线程的事件管理者，或者说是线程的事件管家，他会按照顺序管理线程要处理的事件，决定哪些事件在什么时候提交给主线程处理。</p>
<a id="more"></a>
<h1 id="无处不在的runLoop"><a href="#无处不在的runLoop" class="headerlink" title="无处不在的runLoop"></a>无处不在的runLoop</h1><p>如下，笔者在touchesBegan:withEvent:中打断点，然后查看函数调用栈。其中，红框中的部分是runloop相关的函数。不难发现，整个调用栈可以分为4个部分。自下而上依次为：</p>
<p>1.加载dyld动态库以及dyld加载其他动态库<br>2.执行main函数<br>3.runloop处理source，此处是source0<br>4.UIKit收到source0后处理touch事件<br><img src="https://upload-images.jianshu.io/upload_images/1055199-be104aea54b1dd11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无处不在的runloop"></p>
<p>我们上图中，调用栈中有一个很长的函数——__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__。其实，所有线程的几乎所有的函数都是从以下6个函数调起的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__    // 回调observer的callback指针，通知runloop的activity状态变化</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__                                                // 处理添加到runloop的block</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__                        // 处理分发给主线程的事件</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__            // 处理timer回调</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__        // 处理source0回调</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__        // 处理source1回调</span><br></pre></td></tr></table></figure>

<p>这6个函数名字之所以如此之长，也只是为了实现自解释。通过查看名字我们可以看出这几个函数都是calling_out的，也就是都是<strong>向外</strong>回调的函数。所谓的<strong>向外</strong>是相对于runloop的，其实就是runLoop向上层回调，通过回调函数runloop可以通知上层runloop当前处于什么状态或正在处理什么事件。具体的每个函数的作用会在下文详细解释，不必在此纠结。</p>
<h1 id="runLoop-结构"><a href="#runLoop-结构" class="headerlink" title="runLoop 结构"></a>runLoop 结构</h1><p>runLoop的结构如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1055199-b999548fd7b67fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop结构"></p>
<p>通过上图可以看出：</p>
<ul>
<li>一个thread对应一个runloop</li>
<li>Cocoa层的NSRunLoop是对CF层的CFRunLoop的封装</li>
<li>一个runloop对应多个runLoopMode</li>
<li>一个runloop一次只能执行一个runLoopMode，runloop在同一个时间只能且必须在一种特定mode下run。要想切换runLoopMode需要停止并退出当前RLM重新进入新的runLoopMode。</li>
<li>一次执行一个mode的好处在于，底层设计相对简单，避免不同的mode耦合在一起，代码相互影响</li>
<li>另一个好处是这样可以在不同的mode下执行不同的代码，避免上层业务代码相互影响。</li>
<li>多个mode以及mode的切换是iOS app滑动顺畅的关键。</li>
<li>主线程中不同的代码指定在不同的mode下运行可以提高app的流畅度。</li>
<li>每个runLoopSource包括若干个runLoopSource、若干个runLoopTimer、若干个runLoopObserver。</li>
</ul>
<h2 id="RunLoop结构体定义"><a href="#RunLoop结构体定义" class="headerlink" title="RunLoop结构体定义"></a>RunLoop结构体定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// RunLoop的结构体定义</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">pthread_mutex_t _lock;                        // 访问mode集合时用到的锁</span><br><span class="line">__CFPort _wakeUpPort;                            // 手动唤醒runloop的端口。初始化runloop时设置，仅用于CFRunLoopWakeUp，CFRunLoopWakeUp函数会向_wakeUpPort发送一条消息</span><br><span class="line">pthread_t _pthread;                                // 对应的线程</span><br><span class="line">CFMutableSetRef _commonModes;            // 集合，存储的是字符串，记录所有标记为common的modeName</span><br><span class="line">CFMutableSetRef _commonModeItems;    // 存储所有commonMode的sources、timers、observers</span><br><span class="line">CFRunLoopModeRef _currentMode;        // 当前modeName</span><br><span class="line">CFMutableSetRef _modes;                        // 集合，存储的是CFRunLoopModeRef</span><br><span class="line">struct _block_item *_blocks_head; // 链表头指针，该链表保存了所有需要被runloop执行的block。外部通过调用CFRunLoopPerformBlock函数来向链表中添加一个block节点。runloop会在CFRunLoopDoBlock时遍历该链表，逐一执行block</span><br><span class="line">struct _block_item *_blocks_tail; // 链表尾指针，之所以有尾指针，是为了降低增加block时的时间复杂度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop提供的主要API"><a href="#RunLoop提供的主要API" class="headerlink" title="RunLoop提供的主要API"></a>RunLoop提供的主要API</h2><p>以下API主要包括获取runloop相关函数、runloop运行相关函数、操作source\timer\observer相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 获取RunLoop</span><br><span class="line">CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);</span><br><span class="line">CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);</span><br><span class="line"></span><br><span class="line">// 添加commonMode</span><br><span class="line">CF_EXPORT void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line"></span><br><span class="line">// runloop运行相关</span><br><span class="line">CF_EXPORT void CFRunLoopRun(void);</span><br><span class="line">CF_EXPORT SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);</span><br><span class="line">CF_EXPORT Boolean CFRunLoopIsWaiting(CFRunLoopRef rl);</span><br><span class="line">CF_EXPORT void CFRunLoopWakeUp(CFRunLoopRef rl);</span><br><span class="line">CF_EXPORT void CFRunLoopStop(CFRunLoopRef rl);</span><br><span class="line"></span><br><span class="line">// source相关操作</span><br><span class="line">CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);</span><br><span class="line">CF_EXPORT CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context);</span><br><span class="line">CF_EXPORT void CFRunLoopSourceSignal(CFRunLoopSourceRef source);</span><br><span class="line"></span><br><span class="line">// observer相关操作</span><br><span class="line">CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);</span><br><span class="line">CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context);</span><br><span class="line">CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void (^block) (CFRunLoopObserverRef observer, CFRunLoopActivity activity)) CF_AVAILABLE(10_7, 5_0);</span><br><span class="line"></span><br><span class="line">// timer相关操作</span><br><span class="line">CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context);</span><br><span class="line">CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void (^block) (CFRunLoopTimerRef timer)) CF_AVAILABLE(10_7, 5_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 让runloop执行某个block</span><br><span class="line">* 本质上是把block插入到一个由runloop维护的block对象组成的链表中，在runloop运行中取出链表里被指定在当前mode下运行的block，逐一执行。</span><br><span class="line">*/</span><br><span class="line">CF_EXPORT void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) CF_AVAILABLE(10_6, 4_0);</span><br></pre></td></tr></table></figure>

<h1 id="RunLoop与线程关系"><a href="#RunLoop与线程关系" class="headerlink" title="RunLoop与线程关系"></a>RunLoop与线程关系</h1><p>以下是获取主线程runloop和子线程runloop的函数。可以看出，这两个函数内部都调用了<strong>_CFRunLoopGet0()</strong>，CFRunLoopGet0()的入参是线程。</p>
<p>另外，获取子线程的runloop传入的是pthread_self()函数获取到的当前线程。所以这里可以看出，CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。而主线程却没有这个限制，但是一般场景下也没有在子线程获取主线程runloop的必要。</p>
<h2 id="获取主线程的runloop"><a href="#获取主线程的runloop" class="headerlink" title="获取主线程的runloop"></a>获取主线程的runloop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">CHECK_FOR_FORK();</span><br><span class="line">static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">// 入参是主线程获取runloop</span><br><span class="line">if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取子线程的runloop"><a href="#获取子线程的runloop" class="headerlink" title="获取子线程的runloop"></a>获取子线程的runloop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">CHECK_FOR_FORK();</span><br><span class="line">CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">if (rl) return rl;</span><br><span class="line">// 传入当前线程获取runloop</span><br><span class="line">return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFRunLoopGet0-函数源码"><a href="#CFRunLoopGet0-函数源码" class="headerlink" title="_CFRunLoopGet0()函数源码"></a>_CFRunLoopGet0()函数源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 获取线程对应的runloop最终调用的核心函数</span><br><span class="line">// should only be called by Foundation</span><br><span class="line">// t==0 is a synonym for &quot;main thread&quot; that always works</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">// 线程t为空则默认返回主线程runloop</span><br><span class="line">if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">t = pthread_main_thread_np();</span><br><span class="line">&#125;</span><br><span class="line">__CFLock(&amp;loopsLock);</span><br><span class="line">if (!__CFRunLoops) &#123;</span><br><span class="line">__CFUnlock(&amp;loopsLock);</span><br><span class="line">// 创建一个用于映射线程和runloop关系的字典</span><br><span class="line">CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">// 主线程runloop</span><br><span class="line">CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">// 保存main runloop，main_thread为key，main runloop为value</span><br><span class="line">CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">CFRelease(dict);</span><br><span class="line">&#125;</span><br><span class="line">CFRelease(mainLoop);</span><br><span class="line">__CFLock(&amp;loopsLock);</span><br><span class="line">&#125;</span><br><span class="line">// 根据线程去字典中获取缓存的runloop</span><br><span class="line">CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">__CFUnlock(&amp;loopsLock);</span><br><span class="line">// 未查找到缓存则创建一个runloop兵缓存在字典中</span><br><span class="line">if (!loop) &#123;</span><br><span class="line">CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">__CFLock(&amp;loopsLock);</span><br><span class="line">loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">if (!loop) &#123;</span><br><span class="line">CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">loop = newLoop;</span><br><span class="line">&#125;</span><br><span class="line">// don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">__CFUnlock(&amp;loopsLock);</span><br><span class="line">CFRelease(newLoop);</span><br><span class="line">&#125;</span><br><span class="line">if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">_CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">// 注册一个回调，当线程销毁时，销毁对应的RunLoop</span><br><span class="line">_CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读上面这段代码可以看出：</p>
<ul>
<li>RunLoop和线程的一一对应的，对应的方式是以key-value的方式保存在一个全局字典中</li>
<li>主线程的RunLoop会在初始化全局字典时创建</li>
<li>子线程的RunLoop会在第一次获取的时候创建，如果不获取的话就一直不会被创建</li>
<li>RunLoop会在线程销毁时销毁</li>
</ul>
<h1 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h1><p>mode作为runloop和source\timer\observer之间的桥梁。应用在启动时main runloop会注册5个mode。分别如下：</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>接下来是老生常谈的一段话：<strong>一个 RunLoop 包含若干个 Mode，每个 Mode 又可以包含若干个 Source/Timer/Observer。每次调用 RunLoop  的主函数时，只能指定其中一个 Mode，这个Mode就是runloop的 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个  Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</strong>至于这样设计让其互补影响的好处后面会说。</p>
<p>mode中有一个特殊的mode叫做<strong>commonMode</strong>。commonMode并不是一个真正的mode，而是若干个被标记为commonMode的普通mode。所以commonMode本质上是一个集合，该集合存储的是mode的名字，也就是字符串，记录所有被标记为common的modeName。当我们向commonMode添加source\timer\observer时，本质上是遍历这个集合中的所有的mode，把item依次添加到每个被标记为common的mode中。</p>
<p>在程序启动时，主线程的runloop有两个预置的mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。默认情况下是会处于defaultMode，滑动scrollView列表时runloop会退出defaultMode转而进入trackingMode。所以，有时候我们加到defaultMode中的timer事件，在滑动列表时是不会执行的。不过，kCFRunLoopDefaultMode 和 UITrackingRunLoopMode这两个 Mode 都已经被添加到runloop的commonMode集合中。也就是说，主线程的这两个预置mode默认已经被标记为commonMode。想要我们的timer回调可以在滑动列表的时候依旧执行，只需要把timer这个item添加到commonMode。</p>
<h2 id="Mode结构体定义"><a href="#Mode结构体定义" class="headerlink" title="Mode结构体定义"></a>Mode结构体定义</h2><p>下面是CFRunLoopMode的结构体定义，从RLM的定义不难看出以下信息：</p>
<ul>
<li>定义了一个结构体指针CFRunLoopModeRef指向__CFRunLoopMode *，从此之后通篇只是用CFRunLoopModeRef。相当于：</li>
<li><code>typedef NSString * StringRef;  StringRef name = @&quot;VV木公子&quot;;</code></li>
<li>runLoopMode结构体包含一个名字，用于标识该runLoopMode</li>
<li>runLoopMode包含两个集合，分别存放sources0和source1。之所以用集合而非数组，原因不言而喻</li>
<li>runLoopMode包含两个数组，分别存放observer和timer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">CFStringRef _name;                            // mode名字</span><br><span class="line">Boolean _stopped;                              // mode的状态，标识mode是否停止</span><br><span class="line">CFMutableSetRef _sources0;            // sources0事件集合</span><br><span class="line">CFMutableSetRef _sources1;            // sources1事件集合</span><br><span class="line">CFMutableArrayRef _observers;        // 观察者数组</span><br><span class="line">CFMutableArrayRef _timers;            // 定时器数组</span><br><span class="line">CFMutableDictionaryRef _portToV1SourceMap;     //字典。key是mach_port_t，value是CFRunLoopSourceRef</span><br><span class="line">__CFPortSet _portSet;                        // 端口的集合。保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span><br><span class="line">CFIndex _observerMask;                     // 添加obsever时设置_observerMask为observer的_activities（CFRunLoopActivity状态）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Core Foundation中，针对Mode的操作，苹果只开放了以下3个API（cocoa中也有功能一样的函数，不再列出）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl);                     // 返回当前运行的mode的name</span><br><span class="line">CF_EXPORT CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl);                             // 返回当前RunLoop的所有mode</span><br><span class="line">CF_EXPORT void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode); // 向当前RunLoop的common modes中添加一个mode</span><br></pre></td></tr></table></figure>

<p>我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用CFRunLoopAddCommonMode传入一个字符串向RunLoop中添加一个commonMode，传入的字符串即为Mode的名字，Mode对象应该是此时在RunLoop内部创建的。</p>
<h2 id="添加commonMode源码"><a href="#添加commonMode源码" class="headerlink" title="添加commonMode源码"></a>添加commonMode源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef modeName) &#123;</span><br><span class="line">if (!CFSetContainsValue(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">CFSetRef set = rl-&gt;_commonModeItems ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : NULL;</span><br><span class="line">// 把modeName添加到RunLoop的_commonModes![CFRunLoopRun调用链.png](https://upload-images.jianshu.io/upload_images/1055199-a612b6b9ae4c2a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">中</span><br><span class="line">CFSetAddValue(rl-&gt;_commonModes, modeName);</span><br><span class="line">if (NULL != set) &#123;</span><br><span class="line">// 定义一个长度为2的数组context, 第一个元素是runloop，第二个元素是modeName</span><br><span class="line">CFTypeRef context[2] = &#123;rl, modeName&#125;;</span><br><span class="line">// 把commonModeItems数组中的所有Source/Observer/Timer同步到新添加的mode（CFRunLoopModeRef实例）</span><br><span class="line">// 遍历set集合中的每一个元素作为 __CFRunLoopAddItemsToCommonMode 的第一个参数，context 作为第二个参数，调用__CFRunLoopAddItemsToCommonMode</span><br><span class="line">CFSetApplyFunction(set, (__CFRunLoopAddItemsToCommonMode), (void *)context);</span><br><span class="line">CFRelease(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加item到mode的item集合(数组)中</span><br><span class="line">static void __CFRunLoopAddItemsToCommonMode(const void *value, void *ctx) &#123;</span><br><span class="line">CFTypeRef item = (CFTypeRef)value;</span><br><span class="line">CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);</span><br><span class="line">CFStringRef modeName = (CFStringRef)(((CFTypeRef *)ctx)[1]);</span><br><span class="line">if (CFGetTypeID(item) == CFRunLoopSourceGetTypeID()) &#123;</span><br><span class="line">// item是source就添加到source&quot;集合&quot;中</span><br><span class="line">CFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);</span><br><span class="line">&#125; else if (CFGetTypeID(item) == CFRunLoopObserverGetTypeID()) &#123;</span><br><span class="line">// item是observer就添加到observer&quot;数组&quot;中</span><br><span class="line">CFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);</span><br><span class="line">&#125; else if (CFGetTypeID(item) == CFRunLoopTimerGetTypeID()) &#123;</span><br><span class="line">// item是timer就添加到timer&quot;数组&quot;中</span><br><span class="line">CFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CFRunLoopAddSource\CFRunLoopAddObserver\CFRunLoopAddTimer的源码会在下面分析，此处不再展开。</p>
<h1 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h1><p>如下图所示，__CFRunLoopSource结构体定义中包括两个版本的source，分别是version0和version1。version0和version1分别对应source0和source1。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1055199-5bf6555a673d699b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runloopSource结构体定义"></p>
<ul>
<li><code>typedef struct __CFRunLoopSource * CFRunLoopSourceRef;</code>之所以定义在.h中，是为了给开发者提供创建并使用source的能力。</li>
<li>一个source对应多个runloop。之所以使用CFMutableBagRef这种集合结构保存runloop而非array或set。主要原因是bag是无序的且允许重复。更多信息详见：<a href="https://developer.apple.com/documentation/corefoundation/cfbag-s1l" target="_blank" rel="noopener">https://developer.apple.com/documentation/corefoundation/cfbag-s1l</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopSource * CFRunLoopSourceRef;    // 定义在.h文件中</span><br><span class="line">struct __CFRunLoopSource &#123;</span><br><span class="line">CFIndex _order;            // souce的顺序（不可变）</span><br><span class="line">CFMutableBagRef _runLoops;  // 集合（允许元素重复）说明一个source可以对应多个runloop</span><br><span class="line">union &#123;</span><br><span class="line">CFRunLoopSourceContext version0; // source0的结构体（不可变）</span><br><span class="line">CFRunLoopSourceContext1 version1; // source1的结构体（不可变）</span><br><span class="line">&#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>source对应的runloop是一个集合，说明source可以被添加到多个runloop中。</p>
<h2 id="Source0和Source1区别"><a href="#Source0和Source1区别" class="headerlink" title="Source0和Source1区别"></a>Source0和Source1区别</h2><p>Source0：source0是App内部事件，由App自己管理的，像UIEvent、CFSocket都是source0。source0并不能主动触发事件，当一个source0事件准备处理时，要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理。然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。框架已经帮我们做好了这些调用，比如网络请求的回调、滑动触摸的回调，我们不需要自己处理。 </p>
<p>Source1：由RunLoop和内核管理，Mach port驱动，如CFMachPort、CFMessagePort。source1包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</p>
<h2 id="添加Source的源码"><a href="#添加Source的源码" class="headerlink" title="添加Source的源码"></a>添加Source的源码</h2><p>作用：把source添加到对应mode的source0或source1集合中。只是这里区分了下source被指定的mode是否为commonMode，如果source被指定的mode是commonMode，还需要把source添加到runloop的commonModeItems集合中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;</span><br><span class="line">// 导出runloop的commonMode（如果modeName是commonMode）</span><br><span class="line">if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">// 初始化创建commonModeItems（如果_commonModeItems为空）</span><br><span class="line">if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">&#125;</span><br><span class="line">// 把source添加到commonModeItems集合中</span><br><span class="line">CFSetAddValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">if (NULL != set) &#123;</span><br><span class="line">// 创建一个长度为2的数组，分别存储runloop和runloopSource</span><br><span class="line">CFTypeRef context[2] = &#123;rl, rls&#125;;</span><br><span class="line">// 添加新的item也就是runloopSource到所有的commonMode中</span><br><span class="line">// set是commonMode集合，CFSetApplyFunction遍历set，添加runloopSource到所有被标记为commonMode的mode-&gt;source0(或source1)中</span><br><span class="line">CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 走到这里说明modeName不是commonMode</span><br><span class="line">// 根据modeName和runloop获取runloop的mode</span><br><span class="line">CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">// 初始化创建runloopMode的source0 &amp; source1这个集合(如果为空)</span><br><span class="line">if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) &#123;</span><br><span class="line">rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line">// 如果runloopMode的sources0集合和sources1都不包含将要添加的runloopSource则把runloopSource添加到对应的集合中</span><br><span class="line">if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</span><br><span class="line">if (0 == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">// rls是source0</span><br><span class="line">CFSetAddValue(rlm-&gt;_sources0, rls);</span><br><span class="line">&#125; else if (1 == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">// rls是source1</span><br><span class="line">CFSetAddValue(rlm-&gt;_sources1, rls);</span><br><span class="line">__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</span><br><span class="line">if (CFPORT_NULL != src_port) &#123;</span><br><span class="line">// key是src_port，value是rls，存储到runloopMode的_portToV1SourceMap字典中</span><br><span class="line">CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</span><br><span class="line">__CFPortSetInsert(src_port, rlm-&gt;_portSet);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__CFRunLoopSourceLock(rls);</span><br><span class="line">if (NULL == rls-&gt;_runLoops) &#123;</span><br><span class="line">// source有一个集合成员变量runLoops。source每被添加进一个runloop，都会把runloop添加到他的这个集合中</span><br><span class="line">// 如官方注释所言：sources retain run loops!（source会持有runloop！）</span><br><span class="line">rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!</span><br><span class="line">&#125;</span><br><span class="line">// 更新runloopSource的runLoops集合，将rl添加到rls-&gt;_runloops中</span><br><span class="line">CFBagAddValue(rls-&gt;_runLoops, rl);</span><br><span class="line">__CFRunLoopSourceUnlock(rls);</span><br><span class="line">// 如果rls是source0则doVer0Callout标记置为true，即需要向外调用回调</span><br><span class="line">if (0 == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">if (NULL != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">doVer0Callout = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果是source0，则向外层（上层）调用source0的schedule回调函数</span><br><span class="line">if (doVer0Callout) &#123;</span><br><span class="line">rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);    /* CALLOUT */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UIButton点击事件是source0还是source1？"><a href="#UIButton点击事件是source0还是source1？" class="headerlink" title="UIButton点击事件是source0还是source1？"></a>UIButton点击事件是source0还是source1？</h2><p>UIButton的点击事件到底是source0还是source1，这是很多人困惑的一点。断点打印堆栈看是从source0调出的，而有人说是source1。其实不难理解，我们上面说了，source1是由runloop和内核管理，mach port驱动。所以button的点击事件首先是由source1 接收IOHIDEvent，然后再回调 <strong>IOHIDEventSystemClientQueueCallback() 内触发的source0，source0再触发的 _UIApplicationHandleEventQueue()。所以打印调用堆栈发现UIButton事件是source0触发的。我们可以在 __IOHIDEventSystemClientQueueCallback() 处打一个 Symbolic Breakpoint 来验证这一点。<br>事实上，即便没有点击button，只要触摸屏幕，就会产生一个</strong>CFRunLoopDoSource1 到 __IOHIDEventSystemClientQueueCallback() 的调用过程。而点击按钮时，除了上述流程，会有一条新的调用从 GSEventRunModal -&gt; CFRunLoopRunSpecific -&gt; __CFRunLoopDoSources0，所以看起来按钮点击事件还是直接触发的 source0事件。</p>
<h1 id="RunLoop-timer"><a href="#RunLoop-timer" class="headerlink" title="RunLoop timer"></a>RunLoop timer</h1><p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<h2 id="CFRunLoopTimer结构体"><a href="#CFRunLoopTimer结构体" class="headerlink" title="CFRunLoopTimer结构体"></a>CFRunLoopTimer结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">uint16_t _bits;                            // 标记fire状态</span><br><span class="line">CFRunLoopRef _runLoop;            // timer所处的runloop</span><br><span class="line">CFMutableSetRef _rlModes;        // mode集合。存放所有包含该timer的mode的modeName，意味着一个timer可能会在多个mode中存在</span><br><span class="line">CFAbsoluteTime _nextFireDate;        // 下次触发时间</span><br><span class="line">CFTimeInterval _interval;                // 理想时间间隔(不可变)</span><br><span class="line">CFTimeInterval _tolerance;      // 允许的误差(可变)</span><br><span class="line">CFRunLoopTimerCallBack _callout;// timer回调</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和source不同，timer对应的runloop是一个runloop指针，而非数组，所以此处说明一个timer只能添加到一个runloop。</p>
<h2 id="添加timer的源码"><a href="#添加timer的源码" class="headerlink" title="添加timer的源码"></a>添加timer的源码</h2><p>作用：添加timer到rl-&gt;commonModeItems中，添加timer到runloopMode中，根据触发时间调整timer在runloopMode-&gt;timers数组中的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 添加timer到runloopMode中，添加timer到rl-&gt;commonModeItems中</span><br><span class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </span><br><span class="line"></span><br><span class="line">if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</span><br><span class="line">// 导出runloop的commonMode(如果modeName是commonMode)</span><br><span class="line">if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">// 如果rl-&gt;_commonModeItems为空就初始化rl-&gt;commonModeItems</span><br><span class="line">if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">&#125;</span><br><span class="line">CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">if (NULL != set) &#123;</span><br><span class="line">// 长度为2的数组，分别存放rl和rlt</span><br><span class="line">CFTypeRef context[2] = &#123;rl, rlt&#125;;</span><br><span class="line">// 添加新的item也就是timer到所有的commonMode中</span><br><span class="line">// set是commonMode集合，CFSetApplyFunction遍历set，添加context[1]存放的rlt添加到所有被标记为commonMode的mode中</span><br><span class="line">CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">CFRelease(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 走到这里说明modeName不是commonMode</span><br><span class="line">// 根据runloop和modeName查找对用的mode</span><br><span class="line">CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">if (NULL != rlm) &#123;</span><br><span class="line">if (NULL == rlm-&gt;_timers) &#123;</span><br><span class="line">CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">cb.equal = NULL;</span><br><span class="line">rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">__CFRunLoopTimerLock(rlt);</span><br><span class="line">if (NULL == rlt-&gt;_runLoop) &#123;</span><br><span class="line">rlt-&gt;_runLoop = rl;</span><br><span class="line">&#125; else if (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 更新rlt的rlModes集合。将rlm-&gt;name添加到name中</span><br><span class="line">CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">// Reposition释义复位。所以顾名思义该函数用于复位timer</span><br><span class="line">// 此处调用该函数本质上是按照timer下次触发时间长短，计算timer需要插入到runloopMode-&gt;timers数组中的位置，然后把timer插入到runloopMode-&gt;timers数组中</span><br><span class="line">__CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">__CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">// 为了向后兼容，如果系统版本低于CFSystemVersionLion且timer执行的rl不是当前runloop，则唤醒rl</span><br><span class="line">if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置timer下次触发时间的源码"><a href="#设置timer下次触发时间的源码" class="headerlink" title="设置timer下次触发时间的源码"></a>设置timer下次触发时间的源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef rlt, CFAbsoluteTime fireDate) &#123;</span><br><span class="line">// 触发日期大于最大限制时间，则把触发日期调整为最大触发时间</span><br><span class="line">if (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;</span><br><span class="line">uint64_t nextFireTSR = 0ULL;</span><br><span class="line">uint64_t now2 = mach_absolute_time();</span><br><span class="line">CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();</span><br><span class="line">// 下次触发时间小于现在则立即触发</span><br><span class="line">if (fireDate &lt; now1) &#123;</span><br><span class="line">nextFireTSR = now2;</span><br><span class="line">// 下次触发时间间隔大于允许的最大间隔TIMER_INTERVAL_LIMIT，则将下次触发时间调整为now + TIMER_INTERVAL_LIMIT</span><br><span class="line">&#125; else if (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) &#123;</span><br><span class="line">nextFireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">nextFireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);</span><br><span class="line">&#125;</span><br><span class="line">__CFRunLoopTimerLock(rlt);</span><br><span class="line">if (NULL != rlt-&gt;_runLoop) &#123;</span><br><span class="line">// 获取runloopMode个数</span><br><span class="line">CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</span><br><span class="line">// 声明名为modes的栈结构</span><br><span class="line">STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</span><br><span class="line">// rlt-&gt;rlModes赋值给modes栈结构</span><br><span class="line">CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes);</span><br><span class="line">for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">// 先retain</span><br><span class="line">CFRetain(modes[idx]);</span><br><span class="line">&#125;</span><br><span class="line">CFRunLoopRef rl = (CFRunLoopRef)CFRetain(rlt-&gt;_runLoop);</span><br><span class="line">// 把modes集合中存储的modeName转换为mode结构体实例，然后再存入modes集合</span><br><span class="line">for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">CFStringRef name = (CFStringRef)modes[idx];</span><br><span class="line">modes[idx] = __CFRunLoopFindMode(rl, name, false);</span><br><span class="line">// 后release</span><br><span class="line">CFRelease(name);</span><br><span class="line">&#125;</span><br><span class="line">// 把上面计算好的下次触发时间设置给rlt</span><br><span class="line">rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">rlt-&gt;_nextFireDate = fireDate;</span><br><span class="line">for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</span><br><span class="line">if (rlm) &#123;</span><br><span class="line">// Reposition释义复位。所以顾名思义该函数用于复位timer，所谓复位，就是调整timer在runloopMode-&gt;timers数组中的位置</span><br><span class="line">// 此处调用该函数本质上是先移除timer，然后按照timer下次触发时间长短计算timer需要插入到runloopMode-&gt;timers数组中的位置，最后把timer插入到runloopMode-&gt;timers数组中</span><br><span class="line">__CFRepositionTimerInMode(rlm, rlt, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 以上注释的意思是：这行代码的是为了给timer设置date，但不直接作用于runloop</span><br><span class="line">// 以防万一，我们手动唤醒runloop，尽管有可能这个代价是高昂的</span><br><span class="line">// 另一方面，这么做的目的也是为了兼容timer的之前的实现方式</span><br><span class="line">// 如果timer执行的rl不是当前的runloop，则手动唤醒</span><br><span class="line">if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 走到这里说明timer的rl还是空，所以只是简单的设置timer的下次触发时间</span><br><span class="line">rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">rlt-&gt;_nextFireDate = fireDate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RunLoop-observer"><a href="#RunLoop-observer" class="headerlink" title="RunLoop observer"></a>RunLoop observer</h1><p>Observer顾名思义，观察者，和我们设计模式中的观察者模式如出一辙。每个 Observer 都包含了一个回调（函数指针），observer主要观察runloop的状态变化，然后执行回调函数。runloop可观察的状态主要有6种状态，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// runloop的6种状态，用于通知observer runloop的状态变化</span><br><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0),                    // 即将进入Loop</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    // 即将处理 Timer</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),    // 即将处理 Source</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),    // 即将进入休眠</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    // 刚从休眠中唤醒 但是还没开始处理事件</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),                    // 即将退出Loop</span><br><span class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CFRunLoopObserver结构体定义"><a href="#CFRunLoopObserver结构体定义" class="headerlink" title="CFRunLoopObserver结构体定义"></a>CFRunLoopObserver结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">CFRunLoopRef _runLoop;                          // observer所观察的runloop</span><br><span class="line">CFOptionFlags _activities;                     // CFOptionFlags是UInt类型的别名，_activities用来说明要观察runloop的哪些状态。一旦指定了就不可变。</span><br><span class="line">CFRunLoopObserverCallBack _callout;    // 观察到runloop状态变化后的回调(不可变)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和source不同，observer对应的runloop是一个runloop指针，而非数组，此处说明一个observer只能观察一个runloop，所以observer只能添加到一个runloop的一个或者多个mode中。</p>
<h2 id="添加Observer源码"><a href="#添加Observer源码" class="headerlink" title="添加Observer源码"></a>添加Observer源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</span><br><span class="line">if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">// 导出runloop的commonModes</span><br><span class="line">CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">// 初始化创建commonModeItems</span><br><span class="line">if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">&#125;</span><br><span class="line">// 添加observer到commonModeItems</span><br><span class="line">CFSetAddValue(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">if (NULL != set) &#123;</span><br><span class="line">CFTypeRef context[2] = &#123;rl, rlo&#125;;</span><br><span class="line">// 添加observer到所有被标记为commonMode的mode中</span><br><span class="line">CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rlm = __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</span><br><span class="line">rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</span><br><span class="line">&#125;</span><br><span class="line">if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</span><br><span class="line">Boolean inserted = false;</span><br><span class="line">for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</span><br><span class="line">CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</span><br><span class="line">CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</span><br><span class="line">inserted = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!inserted) &#123;</span><br><span class="line">CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</span><br><span class="line">&#125;</span><br><span class="line">// 设置runloopMode的_observerMask为观察者的_activities（CFRunLoopActivity状态）</span><br><span class="line">rlm-&gt;_observerMask |= rlo-&gt;_activities;</span><br><span class="line">__CFRunLoopObserverSchedule(rlo, rl, rlm);</span><br><span class="line">&#125;</span><br><span class="line">if (NULL != rlm) &#123;</span><br><span class="line">__CFRunLoopModeUnlock(rlm);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Observer来监听runloop状态变化"><a href="#自定义Observer来监听runloop状态变化" class="headerlink" title="自定义Observer来监听runloop状态变化"></a>自定义Observer来监听runloop状态变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* 创建一个observer对象</span><br><span class="line">第一个参数: 告诉系统如何给Observer对象分配存储空间</span><br><span class="line">第二个参数: 需要监听的状态类型</span><br><span class="line">第三个参数: 是否需要重复监听</span><br><span class="line">第四个参数: 优先级</span><br><span class="line">第五个参数: 监听到对应的状态之后的回调</span><br><span class="line">*/</span><br><span class="line">CFRunLoopObserverRef observer =  CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry:</span><br><span class="line">NSLog(@&quot;即将进入RunLoop&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeTimers:</span><br><span class="line">NSLog(@&quot;即将处理timer&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeSources:</span><br><span class="line">NSLog(@&quot;即将处理source&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeWaiting:</span><br><span class="line">NSLog(@&quot;即将进入休眠&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">NSLog(@&quot;从休眠中被唤醒&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopExit:</span><br><span class="line">NSLog(@&quot;即将退出RunLoop&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 给主线程的RunLoop添加observer用于监听runLoop状态</span><br><span class="line">第一个参数:需要监听的RunLoop对象</span><br><span class="line">第二个参数:给指定的RunLoop对象添加的监听对象</span><br><span class="line">第三个参数:在那种模式下监听</span><br><span class="line">*/</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>

<h1 id="RunLoop运行相关源码"><a href="#RunLoop运行相关源码" class="headerlink" title="RunLoop运行相关源码"></a>RunLoop运行相关源码</h1><p>如下图，是CFRunLoop运行相关的几个函数以及调用关系。CFRunLoopRun 调用 CFRunLoopRunSpecific 调用 __CFRunLoopRun。</p>
<p>其中CFRunLoopRunSpecific主要由CFRunLoopRun和CFRunLoopRunInMode调用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1055199-5a2aef8b6653d4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CFRunLoopRun调用链"></p>
<h2 id="CFRunLoopRun源码"><a href="#CFRunLoopRun源码" class="headerlink" title="CFRunLoopRun源码"></a>CFRunLoopRun源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 一个do...while循环 如果不是stop或finish就不断的循环 还可以重新启动runloop</span><br><span class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</span><br><span class="line">int32_t result;</span><br><span class="line">do &#123;</span><br><span class="line">result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFRunLoopRunInMode源码"><a href="#CFRunLoopRunInMode源码" class="headerlink" title="CFRunLoopRunInMode源码"></a>CFRunLoopRunInMode源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFRunLoopRunSpecific源码"><a href="#CFRunLoopRunSpecific源码" class="headerlink" title="CFRunLoopRunSpecific源码"></a>CFRunLoopRunSpecific源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, <span class="built_in">Boolean</span> returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line"><span class="comment">// 如果runloop正在销毁则直接返回finish</span></span><br><span class="line"><span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line"><span class="comment">// 根据指定的modeName获取指定的mode，也就是将要运行的mode</span></span><br><span class="line">CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 出现以下情况就不会return finish：</span></span><br><span class="line"><span class="comment">// 1&gt;.将要运行的mode不为空</span></span><br><span class="line"><span class="comment">// 以下这几条是在__CFRunLoopModeIsEmpty函数中判断的:</span></span><br><span class="line"><span class="comment">// 2&gt;.将要运行的currentMode是source0、source1、timer任一个不为空</span></span><br><span class="line"><span class="comment">// 3&gt;.待执行的block的mode和将要运行的mode相同</span></span><br><span class="line"><span class="comment">// 4&gt;.待执行的block的mode是commonMode且待运行的mode包含在commonMode中</span></span><br><span class="line"><span class="comment">// 5&gt;.待执行的block的mode包含待运行的mode</span></span><br><span class="line"><span class="comment">// 6&gt;.待执行的block的mode包含commonMode且待运行的mode包含在commonMode中</span></span><br><span class="line"><span class="comment">// 所谓待执行的block是外部(开发者)通过调用CFRunLoopPerformBlock函数添加到runloop中的</span></span><br><span class="line"><span class="keyword">if</span> (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line"><span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line">volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">rl-&gt;_currentMode = currentMode;</span><br><span class="line">int32_t result = kCFRunLoopRunFinished;</span><br><span class="line"><span class="comment">// 1.通知observer即将进入runloop</span></span><br><span class="line"><span class="comment">// 这里使用currentMode-&gt;_observerMask 和 kCFRunLoopEntry按位与操作</span></span><br><span class="line"><span class="comment">// 如果按位与的结果不是0则说明即将进入runloop</span></span><br><span class="line"><span class="comment">// 而currentMode-&gt;_observerMask是个什么东西呢？</span></span><br><span class="line"><span class="comment">// currentMode-&gt;_observerMask本质上是Int类型的变量，标识当前mode的CFRunLoopActivity状态</span></span><br><span class="line"><span class="comment">// 那么currentMode-&gt;_observerMask是在哪里赋值的呢？</span></span><br><span class="line"><span class="comment">// 调用CFRunLoopAddObserver函数向runloop添加observer的时候会把observer的activities按位或赋值给mode-&gt;_observerMask</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line"><span class="comment">// RunLoop的运行的最核心函数</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"><span class="comment">// 10.通知observer即将退出runloop</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">rl-&gt;_currentMode = previousMode;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFRunLoopRun源码-1"><a href="#CFRunLoopRun源码-1" class="headerlink" title="__CFRunLoopRun源码"></a>__CFRunLoopRun源码</h2><p>这个函数时runloop运行的核心函数，几乎所有的事件都在这个函数中被处理。笔者为了保持源码的味道，并没有对这个函数进行过分精简，所以看起来很长。参考注释可以迅速的了解函数的运行原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">/**RunLoop的运行的最核心函数（进入和退出时runloop和runloopMode都会被加锁）</span><br><span class="line">* rl: 运行的runloop</span><br><span class="line">* rlm: runloop Mode</span><br><span class="line">* seconds: runloop超时时间</span><br><span class="line">* stopAfterHandle: 处理完时间后runloop是否stop，默认为false</span><br><span class="line">* previousMode: runloop上次运行的mode</span><br><span class="line">*/</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">// 获取基于系统启动后的时钟&quot;嘀嗒&quot;数，其单位是纳秒</span><br><span class="line">uint64_t startTSR = mach_absolute_time();</span><br><span class="line">// 状态判断</span><br><span class="line">if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">__CFRunLoopUnsetStopped(rl);</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">rlm-&gt;_stopped = false;</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">&#125;</span><br><span class="line">// 获取主线程接收消息的port备用。如果runLoop是mainRunLoop且后续内核唤醒的port等于主线程接收消息的port，主线程就处理这个消息</span><br><span class="line">mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line"></span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">// 初始化获取timer的port(source1)</span><br><span class="line">// 如果这个port和mach_msg发消息的livePort相等则说明timer时间到了，处理timer</span><br><span class="line">mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">if (rlm-&gt;_queue) &#123;</span><br><span class="line">modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">// 使用GCD实现runloop超时功能</span><br><span class="line">dispatch_source_t timeout_timer = NULL;</span><br><span class="line">struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</span><br><span class="line">// seconds是设置的runloop超时时间，一般为1.0e10，11.574万年，所以不会超时</span><br><span class="line">if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">seconds = 0.0;</span><br><span class="line">timeout_context-&gt;termTSR = 0ULL;</span><br><span class="line">&#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">dispatch_retain(timeout_timer);</span><br><span class="line">timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">// 设置超时的时间点（从现在开始 + 允许运行的时长）</span><br><span class="line">timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">dispatch_resume(timeout_timer);</span><br><span class="line">&#125; else &#123; // infinite timeout</span><br><span class="line">seconds = 9999999999.0;</span><br><span class="line">timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Boolean didDispatchPortLastTime = true;</span><br><span class="line">// returnValue 标识runloop状态，如果returnValue不为0就不退出。</span><br><span class="line">// returnValue可能的值：</span><br><span class="line">// enum &#123;</span><br><span class="line">//     kCFRunLoopRunFinished = 1,</span><br><span class="line">//     kCFRunLoopRunStopped = 2,</span><br><span class="line">//     kCFRunLoopRunTimedOut = 3,</span><br><span class="line">//     kCFRunLoopRunHandledSource = 4</span><br><span class="line">// &#125;;</span><br><span class="line">int32_t retVal = 0;</span><br><span class="line">do &#123;</span><br><span class="line">voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">voucher_t voucherCopy = NULL;</span><br><span class="line">// 消息缓冲区，用户缓存内核发的消息</span><br><span class="line">uint8_t msg_buffer[3 * 1024];</span><br><span class="line">// 消息缓冲区指针，用于指向msg_buffer</span><br><span class="line">mach_msg_header_t *msg = NULL;</span><br><span class="line">// 用于保存被内核唤醒的端口（调用mach_msg函数时会把livePort地址传进去供内核写数据）</span><br><span class="line">mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">__CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">__CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">// __CFRunLoopDoObservers内部会调用__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__这个函数，这个函数的参数包括observer的回调函数、observer、runloop状态</span><br><span class="line">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">//  执行被加入的block</span><br><span class="line">// 外部通过调用CFRunLoopPerformBlock函数向当前runloop增加block。新增加的block保存咋runloop.blocks_head链表里。</span><br><span class="line">// __CFRunLoopDoBlocks会遍历链表取出每一个block，如果block被指定执行的mode和当前的mode一致，则调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__执行之</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">// 4. RunLoop 触发 Source0 (非port) 回调</span><br><span class="line">// __CFRunLoopDoSources0函数内部会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__函数</span><br><span class="line">// __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__函数会调用source0的perform回调函数，即rls-&gt;context.version0.perform</span><br><span class="line">Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">// 如果rl处理了source0事件，那再处理source0之后的block</span><br><span class="line">if (sourceHandledThisLoop) &#123;</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#125;</span><br><span class="line">// 标记是否需要轮询，如果处理了source0则轮询，否则休眠</span><br><span class="line">Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">// 5. 如果有 Source1 (基于port的source) 处于 ready 状态，直接处理这个 Source1 然后跳转到第9步去处理消息。</span><br><span class="line">// __CFRunLoopServiceMachPort函数内部调用了mach_msg，mach_msg函数会监听内核给端口发送的消息</span><br><span class="line">// 如果mach_msg监听到消息就会执行goto跳转去处理这个消息</span><br><span class="line">// 第五个参数为0代表不休眠立即返回</span><br><span class="line">if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">goto handle_msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">didDispatchPortLastTime = false;</span><br><span class="line">// 6. 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">// 根据上面第4步是否处理过source0，来判断如果也没有source1消息的时候是否让线程进入睡眠</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">// runloop置为休眠状态</span><br><span class="line">__CFRunLoopSetSleeping(rl);</span><br><span class="line">// 通知进入休眠状态后，不要做任何用户级回调</span><br><span class="line">__CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">// 标记休眠开始时间</span><br><span class="line">CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">do &#123;</span><br><span class="line">msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">// 7. __CFRunLoopServiceMachPort内部调用mach_msg函数等待接受mach_port的消息。随即线程将进入休眠，等待被唤醒。 以下事件会会唤醒runloop:</span><br><span class="line">// mach_msg接收到来自内核的消息。本质上是内核向我们的port发送了一条消息。即收到一个基于port的Source事件（source1）。</span><br><span class="line">// 一个timer的时间到了（处理timer）</span><br><span class="line">// RunLoop自身的超时时间到了（几乎不可能）</span><br><span class="line">// 被其他调用者手动唤醒（source0）</span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br><span class="line">while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">if (rlm-&gt;_timerFired) &#123;</span><br><span class="line">// Leave livePort as the queue port, and service timers below</span><br><span class="line">rlm-&gt;_timerFired = false;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Go ahead and leave the inner loop.</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">#else</span><br><span class="line">msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">// 计算线程沉睡的时长</span><br><span class="line">rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">__CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line"></span><br><span class="line">__CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">// runloop置为唤醒状态</span><br><span class="line">__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">// 8. 通知 Observers: RunLoop对应的线程刚被唤醒。</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">// 9. 收到&amp;处理source1消息（第5步的goto会到达这里开始处理source1）</span><br><span class="line">handle_msg:;</span><br><span class="line">// 忽略端口唤醒runloop，避免在处理source1时通过其他线程或进程唤醒runloop(保证线程安全)</span><br><span class="line">__CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">if (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">// livePort为null则什么也不做</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">// handle nothing</span><br><span class="line">&#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">// livePort为wakeUpPort则只需要简单的唤醒runloop（rl-&gt;_wakeUpPort是专门用来唤醒runloop的）</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">&#125;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调</span><br><span class="line">// __CFRunLoopDoTimers返回值代表是否处理了这个timer</span><br><span class="line">if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">__CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">__CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">else if (livePort == dispatchPort) &#123;</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">/// 9.2 如果有dispatch到main_queue的block，执行block（也就是处理GCD通过port提交到主线程的事件）。</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">sourceHandledThisLoop = true;</span><br><span class="line">didDispatchPortLastTime = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">// 根据livePort获取source（不需要name，从mode-&gt;_portToV1SourceMap字典中以port作为key即可取到source）</span><br><span class="line">CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">if (rls) &#123;</span><br><span class="line">mach_msg_header_t *reply = NULL;</span><br><span class="line">// 处理source1事件（触发source1的回调）</span><br><span class="line">// runloop 触发source1的回调，__CFRunLoopDoSource1内部会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">// 如果__CFRunLoopDoSource1响应的数据reply不为空则通过mach_msg 再send给内核</span><br><span class="line">if (NULL != reply) &#123;</span><br><span class="line">(void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">/// 执行加入到Loop的block</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">/// 进入loop时参数说处理完事件就返回。</span><br><span class="line">retVal = kCFRunLoopRunHandledSource; // 4</span><br><span class="line">&#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">/// 超出传入参数标记的超时时间了</span><br><span class="line">retVal = kCFRunLoopRunTimedOut; // 3</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">/// 被外部调用者强制停止了</span><br><span class="line">__CFRunLoopUnsetStopped(rl); // 2</span><br><span class="line">retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">// 调用了_CFRunLoopStopMode将mode停止了</span><br><span class="line">rlm-&gt;_stopped = false;</span><br><span class="line">retVal = kCFRunLoopRunStopped; // 2</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">// source/timer/observer一个都没有了</span><br><span class="line">retVal = kCFRunLoopRunFinished; // 1</span><br><span class="line">&#125;</span><br><span class="line">// 如果retVal不是0，即未超时，mode不是空，loop也没被停止，那继续loop</span><br><span class="line">&#125; while (0 == retVal);</span><br><span class="line"></span><br><span class="line">if (timeout_timer) &#123;</span><br><span class="line">dispatch_source_cancel(timeout_timer);</span><br><span class="line">dispatch_release(timeout_timer);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">free(timeout_context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图，笔者绘制了一张详细的函数调用图说明上述runloop的整个调用过程：<br><img src="https://upload-images.jianshu.io/upload_images/1055199-060b9f95b7a85b37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop运行主要函数调用"></p>
<h2 id="手动唤醒runloop的方式"><a href="#手动唤醒runloop的方式" class="headerlink" title="手动唤醒runloop的方式"></a>手动唤醒runloop的方式</h2><ul>
<li>static void __CFRunLoopTimeout(void *arg) {}</li>
<li>The interval is DISPATCH_TIME_FOREVER, so this won’t fire again。因为runloop的执行时长是forever，所有runloop永远不会超时，也就说函数__CFRunLoopTimeout永远不会执行到。</li>
<li>CFRunLoopStop(CFRunLoopRef rl) {}</li>
<li>调用了CFRunLoopStop代表runloop被强制终止了。即便调用了CFRunLoopWakeUp，当前的runloop也永远不会被唤醒了**。因为CFRunLoopStop函数内部调用了_ _CFRunLoopSetStopped函数。而<code>__CFRunLoopSetStopped</code>的实现是<code>rl-&gt;_perRunData-&gt;stopped = 0x53544F50;    // &#39;STOP&#39;</code>。加之CFRunLoopWakeUp函数中通过调用<code>__CFRunLoopIsIgnoringWakeUps(rl)</code>检查了rl-&gt;_perRunData-&gt;stopped的值是否为true，如果值为true则CFRunLoopWakeUp函数直接返回，不再执行唤醒操作。详细代码如下：</li>
<li>CF_EXPORT void _CFRunLoopStopMode(CFRunLoopRef rl, CFStringRef modeName) {}</li>
<li>_CFRunLoopStopMode函数只是通过modeName查找对应的mode，然后把mode的stopped置为true <code>rlm-&gt;_stopped = true;</code>。不会操作runloop-&gt;perRunData-&gt;stopped。</li>
<li>void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {}</li>
<li>CFRunLoopAddTimer函数调用CFRunLoopWakeUp函数纯粹是为了向后兼容，如果系统版本低于CFSystemVersionLion且timer执行的rl不是当前runloop，则唤醒rl。</li>
<li>通常情况下，在主流机型上，CFRunLoopAddTimer函数不会调用到CFRunLoopWakeUp函数，但因为timer handler发生了变化，所以需要兼容旧的实现。在旧版本系统上调用CFRunLoopWakeUp函数。</li>
<li>static void __CFRunLoopSourceWakeUpLoop(const void <em>value, void</em> context) {}</li>
<li>直接调用<code>CFRunLoopWakeUp((CFRunLoopRef)value);</code></li>
<li>void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef rlt, CFAbsoluteTime fireDate) {}</li>
<li>如果timer执行的rl不是当前的runloop，则调用<code>CFRunLoopWakeUp</code>手动唤醒rl</li>
</ul>
<p><strong>除手动滑动runloop外，内核通过向port发送消息也可以自动唤醒runloop。</strong></p>
<h2 id="手动唤醒runloop的代码"><a href="#手动唤醒runloop的代码" class="headerlink" title="手动唤醒runloop的代码"></a>手动唤醒runloop的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopWakeUp(CFRunLoopRef rl) &#123;</span><br><span class="line">// __CFSendTrivialMachMessage内部调用mach_msg函数向runloop的wakeUpPort发送消息以唤醒runloop</span><br><span class="line">kern_return_t ret = __CFSendTrivialMachMessage(rl-&gt;_wakeUpPort, 0, MACH_SEND_TIMEOUT, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 手动调用 mach_msg 向 rl-&gt;_wakeUpPort sendMsg 以唤醒runloop</span><br><span class="line">static uint32_t __CFSendTrivialMachMessage(mach_port_t port, uint32_t msg_id, CFOptionFlags options, uint32_t timeout) &#123;</span><br><span class="line">kern_return_t result;</span><br><span class="line">// 配置header...</span><br><span class="line">mach_msg_header_t header;</span><br><span class="line">header.msgh_remote_port = port;</span><br><span class="line">header.msgh_id = msg_id; </span><br><span class="line">// 向内核发送消息唤醒runloop</span><br><span class="line">result = mach_msg(&amp;header, MACH_SEND_MSG|options, header.msgh_size, 0, MACH_PORT_NULL, timeout, MACH_PORT_NULL);</span><br><span class="line">// ... </span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a>GCD和RunLoop的关系</h1><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch  会向<strong>主线程的RunLoop</strong>发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调  __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个  block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。那么你肯定会问：为什么子线程没有这个和GCD交互的逻辑？原因有二：</p>
<ul>
<li>主线程runloop是主线程的事件管理者。runloop负责何时让runloop处理何种事件。所有分发个主线程的任务必须统一交给主线程runloop排队处理。举例：UI操作只能在主线程，不在主线程操作UI会带来很多UI错乱问题以及UI更新延迟问题。</li>
<li>子线程不接受GCD的交互。因为子线程不一定会有runloop。</li>
</ul>
<h1 id="AutoreleasePool和RunLoop的关系"><a href="#AutoreleasePool和RunLoop的关系" class="headerlink" title="AutoreleasePool和RunLoop的关系"></a>AutoreleasePool和RunLoop的关系</h1><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠)  时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush()  释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个  Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h1 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h1><h2 id="苹果对runloop的使用"><a href="#苹果对runloop的使用" class="headerlink" title="苹果对runloop的使用"></a>苹果对runloop的使用</h2><p>苹果在AutoreleasePool、手势识别、事件响应、UI更新、定时器、NSObject延时调用方法（performSelecter:afterDelay: ）等方面都有使用RunLoop。有兴趣的同学可以研究一下官方源码。</p>
<h2 id="AFNetworking对runloop的使用"><a href="#AFNetworking对runloop的使用" class="headerlink" title="AFNetworking对runloop的使用"></a>AFNetworking对runloop的使用</h2><p>另外，众所周知，为了线程保活，AFNetworking内部也使用了runLoop：通过给子线程添加一个runloop来保证这个子线程不退出。这样，当需要这个子线程执行任务时，AFNetworking 通过调用 NSObject performSelector:onThread:.. 将任务抛给这个子线程的 RunLoop 即可。</p>
<h2 id="SDWebImage对runloop的使用"><a href="#SDWebImage对runloop的使用" class="headerlink" title="SDWebImage对runloop的使用"></a>SDWebImage对runloop的使用</h2><p>SDWebImage中的动画播放类SDAnimatedImageView中也有runloop的影子。该类暴露了一个runloopMode属性，开发者可以指定动画播放的runloopMode，如果不指定则会使用内部默认的mode。这个runloopMode属性最终传递给了SDDisplayLink，SDDisplayLink在iOS平台上是对CADisplayLink的封装。最终通过调用CADisplyLink的实例方法<strong>- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</strong>将的runloopMode设置给CADisplayLink。</p>
<h2 id="React-Native对runloop的使用"><a href="#React-Native对runloop的使用" class="headerlink" title="React Native对runloop的使用"></a>React Native对runloop的使用</h2><p>笔者最近读了React Native的源码，发现React Native中也是用了runloop。其中的RCTMessageThread就是C++对CFRunloop的封装。<br>其他有使用runLoop的地方还有卡顿监控、异步绘制等。总之，只要我们想要保活线程能够随时处理任务，这个线程必须要有runloop。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，结合源码分析runLoop基本告一段落，因为篇幅限制，本文对runLoop的应用一带而过，感兴趣的同学可以深入研究。笔者此处用一句话概括runLoop：runLoop是一个有状态的、事件驱动的do…while循环。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://developer.apple.com/documentation/corefoundation/cfbag-s1l" target="_blank" rel="noopener">CFBag</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">RunLoop</a><br><a href="https://developer.apple.com/documentation/corefoundation/cfoptionflags" target="_blank" rel="noopener"> CFOptionFlags</a><br><a href="https://www.cnblogs.com/zpsoe/p/6994811.html" target="_blank" rel="noopener">mach_absolute_time 使用</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解runloop</a><br><a href="https://juejin.im/post/5b6817aee51d4519610e44f7" target="_blank" rel="noopener">CFRunLoop掘金</a></p>
<p>本文为原创文章，转载请获得授权。</p>

        
    </section>
</article>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "wsv587.github.io",
        owner: "wsv587",
        admin: ["wsv587"],
        id: "2020/05/23/一份走心的runloop源码分析",
        distractionFreeMode: true,
        title: "一份走心的runloop源码分析",
        body: "http://yoursite.com/2020/05/23/一份走心的runloop源码分析/",
        labels: ["iOS","runloop"]
    }).render('comments');
    </script>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script>
    

</body>
</html>
