<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">

    

    

    <title>详解ReactNative初始化和通信机制 | 技术线博客</title>
    <meta name="author" content="wsv587">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content="致敬开始准备写这一篇文章的时候，中国的新型冠状病毒肺炎疫情还在继续，累积确诊81058人，现存确诊10827人。这篇文章写完的时候，累计确诊81501人，现存确认5846人。疫情已经持续了3个月，但也终将过去。毫无疑问，在这漫长的3个月的时间里，很多与疫情抗争的工作人员都是非常辛苦的，再次感谢&amp;amp;致敬。前言这是一篇原理性文章，也是一篇源码分析文章。这篇文章是笔者学习RN源码过程中的一篇记录文章，主要记录了程序从启动之初到开始执行JS源码的整个流程。从AppDelegate的appl...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="技术线博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">技术线博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/iOS">
                <span class="nav-text">iOS</span>
            </a>
        
            <a class="nav-item" href="/categories/front-end">
                <span class="nav-text">前端</span>
            </a>
        
            <a class="nav-item" href="/categories/back-end">
                <span class="nav-text">后端</span>
            </a>
        
            <a class="nav-item" href="/categories/leader">
                <span class="nav-text">领导</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#致敬"><span class="toc-number">1.</span> <span class="toc-text">致敬</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#名词"><span class="toc-number">3.</span> <span class="toc-text">名词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开始"><span class="toc-number">4.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RCTBridge初始化"><span class="toc-number">5.</span> <span class="toc-text">RCTBridge初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSExecutorFactory"><span class="toc-number">5.1.</span> <span class="toc-text">JSExecutorFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageQueueThread"><span class="toc-number">5.2.</span> <span class="toc-text">MessageQueueThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ModuleRegistry"><span class="toc-number">5.3.</span> <span class="toc-text">ModuleRegistry</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NativeToJSBridge"><span class="toc-number">6.</span> <span class="toc-text">NativeToJSBridge</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NativeToJSBridge定义"><span class="toc-number">6.1.</span> <span class="toc-text">NativeToJSBridge定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NativeToJsBridge构造函数"><span class="toc-number">6.2.</span> <span class="toc-text">NativeToJsBridge构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSIExecutor"><span class="toc-number">7.</span> <span class="toc-text">JSIExecutor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#加载JS代码"><span class="toc-number">8.</span> <span class="toc-text">加载JS代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步加载bundle"><span class="toc-number">8.1.</span> <span class="toc-text">同步加载bundle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步加载bundle"><span class="toc-number">8.2.</span> <span class="toc-text">异步加载bundle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#执行JS代码"><span class="toc-number">9.</span> <span class="toc-text">执行JS代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#evaluateJavaScript"><span class="toc-number">9.0.1.</span> <span class="toc-text">evaluateJavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush"><span class="toc-number">9.0.2.</span> <span class="toc-text">flush</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Native调用JS"><span class="toc-number">10.</span> <span class="toc-text">Native调用JS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS调用Native"><span class="toc-number">11.</span> <span class="toc-text">JS调用Native</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#三个疑问"><span class="toc-number">11.1.</span> <span class="toc-text">三个疑问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#大结局"><span class="toc-number">12.</span> <span class="toc-text">大结局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bridge初始化阶段"><span class="toc-number">12.1.</span> <span class="toc-text">bridge初始化阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码加载阶段"><span class="toc-number">12.2.</span> <span class="toc-text">源码加载阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码执行阶段"><span class="toc-number">12.3.</span> <span class="toc-text">源码执行阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行JS-Application阶段"><span class="toc-number">12.4.</span> <span class="toc-text">运行JS Application阶段</span></a></li></ol></li>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            详解ReactNative初始化和通信机制
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://yoursite.com/2020/03/04/详解ReactNative初始化和通信机制/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-03-03T20:20:58.000Z" itemprop="datePublished">2020-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ReactNative/">ReactNative</a>, <a class="article-tag-link" href="/tags/iOS/">iOS</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="致敬"><a href="#致敬" class="headerlink" title="致敬"></a>致敬</h1><p>开始准备写这一篇文章的时候，中国的新型冠状病毒肺炎疫情还在继续，累积确诊81058人，现存确诊10827人。这篇文章写完的时候，累计确诊81501人，现存确认5846人。疫情已经持续了3个月，但也终将过去。毫无疑问，在这漫长的3个月的时间里，很多与疫情抗争的工作人员都是非常辛苦的，再次感谢&amp;致敬。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇原理性文章，也是一篇源码分析文章。这篇文章是笔者学习RN源码过程中的一篇记录文章，主要记录了程序从启动之初到开始执行JS源码的整个流程。从AppDelegate的application:didFinishLaunchingWithOptions:说起，全流程涉及到关键类的初始化工作和JavaScript的执行以及JS&amp;Native之间的通信。围绕bridge的初始化、JS源码的加载、JS源码的执行、Native调用JS、JS调用Native展开分析。内容虽然很长，但其实很浅，大部分都是源码，并没有加入自己太多的思考，耐心看完就可以理解。</p>
<p>本文篇幅很长的原因是笔者贴出了大量的RN源码。文章中的源码已经做了精简，如果想看完整的代码还是建议参考RN源码。笔者主要删除了源码中与逻辑无强关联的代码。比如debug环境的宏、锁、调试相关的代码、健壮性相关的代码、错误处理相关的代码、代码执行耗时相关的代码。删除这些代码不会影响对源码的阅读和理解，请大家放心。</p>
<p>阅读这篇文章你最好具备以下条件：你应该是一个iOS开发者，本文是站在一个iOS工程的角度分析RN的源码，当然如果你能看懂Objective-C代码也是可以的。你应该对RN有所了解，最好是使用RN开发过一些需求。你应该对JS有所了解，本文会涉及少量JS代码。最后，你最好具备一些C++的知识，RN源码中存在大量的C++代码，不需要会写，了解C++语法能看懂C++代码即可。当然，如果你认为万物皆对象，以上条件都可以忽略，那么让我们开始吧》》》</p>
<p><strong>本文基于React Native 0.61.5进行分析</strong>。</p>
<a id="more"></a>

<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><p>本文中主要涉及到以下几个类:RCTBridge、RCTCxxBridge、Instance、NativeToJsBridge、JsToNativeBridge、JSIExecutor、RCTRootView。他们的关系大概如下（JSIExecutor是本文涉及到的最内层的类）：</p>
<p><img src="/2020/03/04/详解ReactNative初始化和通信机制/ReactNative%E5%85%B3%E9%94%AE%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="React Native关键类关系图"></p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>我们新建一个名为NewProject的RN的iOS工程。可以看出AppDelegate.m的application: didFinishLaunchingWithOptions:方法实现是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">// 1.初始化bridge</span><br><span class="line">RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];</span><br><span class="line">// 2.初始化rootView</span><br><span class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge</span><br><span class="line">moduleName:@&quot;NewProject&quot;</span><br><span class="line">initialProperties:nil];</span><br><span class="line"></span><br><span class="line">rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];</span><br><span class="line">// 3.设置rootViewController</span><br><span class="line">self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">UIViewController *rootViewController = [UIViewController new];</span><br><span class="line">rootViewController.view = rootView;</span><br><span class="line">self.window.rootViewController = rootViewController;</span><br><span class="line">[self.window makeKeyAndVisible];</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可以看出，application:didFinishLaunchWithOptions:主要做了3件事：</p>
<p>1.初始化一个RCTBridge实例</p>
<p>2.再用RCTBridge实例初始化一个rootView</p>
<p>3.用rootView配置一个rootViewController</p>
<p>第三步用rootView初始化一个rootViewController没什么可说的，本片文章我们主要窥探初始化RCTBridge和RCTRootView。</p>
<h1 id="RCTBridge初始化"><a href="#RCTBridge初始化" class="headerlink" title="RCTBridge初始化"></a>RCTBridge初始化</h1><p>RCTBridge初始化是重点也是难点，虽然叫RCTBridge的初始化，但实际上不仅仅是初始化一个RCTBridge实例那么简单，在其背后还有RCTCxxBridge、NativeToJSBridge、JSExecutor(JSIExecutor生产环境/RCTObjcExecutor调试环境)、JsToNativeBridge的初始化，这里仅作为一个了解，不必纠结，后面会详细介绍。先来看一下appDelegate中调用的RCTBridge的初始化的源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// RCTBridge.m</span><br><span class="line">- (instancetype)initWithDelegate:(id&lt;RCTBridgeDelegate&gt;)delegate</span><br><span class="line">bundleURL:(NSURL *)bundleURL</span><br><span class="line">moduleProvider:(RCTBridgeModuleListProvider)block</span><br><span class="line">launchOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">_delegate = delegate;</span><br><span class="line">_bundleURL = bundleURL;</span><br><span class="line">_moduleProvider = block;</span><br><span class="line">_launchOptions = [launchOptions copy];</span><br><span class="line"></span><br><span class="line">[self setUp];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUp</span><br><span class="line">&#123;</span><br><span class="line">// 获取bridgeClass 默认是RCTCxxBridge</span><br><span class="line">Class bridgeClass = self.bridgeClass;</span><br><span class="line"></span><br><span class="line">// 只有delegate返回的bundleURL发生变化才更新_bundleURL</span><br><span class="line">NSURL *previousDelegateURL = _delegateBundleURL;</span><br><span class="line">_delegateBundleURL = [self.delegate sourceURLForBridge:self];</span><br><span class="line">if (_delegateBundleURL &amp;&amp; ![_delegateBundleURL isEqual:previousDelegateURL]) &#123;</span><br><span class="line">_bundleURL = _delegateBundleURL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化self.batchedBridge，也就是RCTCxxBridge</span><br><span class="line">self.batchedBridge = [[bridgeClass alloc] initWithParentBridge:self];</span><br><span class="line"></span><br><span class="line">// 启动RCTCxxBridge</span><br><span class="line">[self.batchedBridge start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// self.bridgeClass</span><br><span class="line">- (Class)bridgeClass</span><br><span class="line">&#123;</span><br><span class="line">return [RCTCxxBridge class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面RCTBridge的初始化方法是创建了一个RCTBridge实例，通过调用私有方法setUp对bridge进行配置。setUp主要做了2件事情：</p>
<p>1.初始化self.batchedBridge，也就是RCTCxxBridge实例</p>
<p>2.启动self.bathedBridge（RCTCxxBridge实例）</p>
<p>self.batchedBridge的start源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line"></span><br><span class="line">// 1.提前设置并开启JS线程 _jsThread</span><br><span class="line">_jsThread = [[NSThread alloc] initWithTarget:[self class]</span><br><span class="line">selector:@selector(runRunLoop)</span><br><span class="line">object:nil];</span><br><span class="line">_jsThread.name = RCTJSThreadName; // @&quot;com.facebook.react.JavaScript&quot;</span><br><span class="line">_jsThread.qualityOfService = NSOperationQualityOfServiceUserInteractive;</span><br><span class="line">[_jsThread start];</span><br><span class="line"></span><br><span class="line">dispatch_group_t prepareBridge = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">// 2.初始化注册native module</span><br><span class="line">[self registerExtraModules];</span><br><span class="line">// 初始化所有不能被懒加载的native module</span><br><span class="line">[self _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO];</span><br><span class="line">[self registerExtraLazyModules];</span><br><span class="line"></span><br><span class="line">_reactInstance.reset(new Instance);</span><br><span class="line">__weak RCTCxxBridge *weakSelf = self;</span><br><span class="line"></span><br><span class="line">// 准备executor factory</span><br><span class="line">std::shared_ptr&lt;JSExecutorFactory&gt; executorFactory;</span><br><span class="line">if (!self.executorClass) &#123;</span><br><span class="line">if ([self.delegate conformsToProtocol:@ (RCTCxxBridgeDelegate)]) &#123;</span><br><span class="line">id&lt;RCTCxxBridgeDelegate&gt; cxxDelegate = (id&lt;RCTCxxBridgeDelegate&gt;) self.delegate;</span><br><span class="line">executorFactory = [cxxDelegate jsExecutorFactoryForBridge:self];</span><br><span class="line">&#125;</span><br><span class="line">if (!executorFactory) &#123;</span><br><span class="line">executorFactory = std::make_shared&lt;JSCExecutorFactory&gt;(nullptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">id&lt;RCTJavaScriptExecutor&gt; objcExecutor = [self moduleForClass:self.executorClass];</span><br><span class="line">executorFactory.reset(new RCTObjcExecutorFactory(objcExecutor, ^(NSError *error) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">[weakSelf handleError:error];</span><br><span class="line">&#125;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.module初始化完就初始化底层Instance实例，也就是_reactInstance</span><br><span class="line">// 在JS线程初始化_reactInstance、RCTMessageThread、nativeToJsBridge、JSCExecutor</span><br><span class="line">dispatch_group_enter(prepareBridge);</span><br><span class="line">[self ensureOnJavaScriptThread:^&#123;</span><br><span class="line">[weakSelf _initializeBridge:executorFactory];</span><br><span class="line">dispatch_group_leave(prepareBridge);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 4.异步加载JS代码</span><br><span class="line">dispatch_group_enter(prepareBridge);</span><br><span class="line">__block NSData *sourceCode;</span><br><span class="line">[self loadSource:^(NSError *error, RCTSource *source) &#123;</span><br><span class="line">sourceCode = source.data;</span><br><span class="line">dispatch_group_leave(prepareBridge);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 5.等待native moudle 和 JS 代码加载完毕后就执行JS</span><br><span class="line">dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0), ^&#123;</span><br><span class="line">RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">if (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">[strongSelf executeSourceCode:sourceCode sync:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个start方法很关键，是RCTCxxBridge中最主要的方法。因为做的事情较多且掺杂着部分C++代码， 所以让人觉得很复杂，梳理一下，其实start中主要做了5件事：</p>
<p>1.创建并开启一个JS线程(_jsThread)，该线程绑定了一个runloop，顾名思义，这个线程就是用来执行JS代码的，后续所有的js代码都是在这个线程里执行。</p>
<p>2.初始化注册所有要暴露给js调用的native module，每个native module类都封装成一个RCTModuleData实例，如果需要在主线程中创建某些类的实例，则会在主线程中去创建实例。这些RCTModuleData会分别存储在字典和数组里。</p>
<p>3.准备JS和Native之间的桥和JS运行环境，初始化JSExecutorFactory实例（顾名思义，JSExecutorFactory是一个JSExecutor的工厂，也就是负责生产JSExecutor实例的工厂），然后在JS线程中创建JS的RCTMessageThread，初始化_reactInstance（Instance实例）、nativeToJsBridge（NativeToJsBridge实例）、executor（JSIExecutor实例）。以上这些事情主要是在_initializeBridge:方法中完成的，此处作为了解，后面详细分析。</p>
<p>4.异步加载JS源码</p>
<p>5.native module和JS代码都加载完毕后就执行JS代码</p>
<blockquote>
<p> 以上提到了三个C++类Instance、NativeToJsBridge、JSIExecutor，他们都是native call JS的桥梁。但有什么区别呢？其实他们的关系是Instance-&gt;NativeToJsBridge-&gt;JSIExecutor。即Instance中创建并持有NativeToJsBridge实例，NativeToJsBridge中又创建并持有JSIExecutor实例。换句话说，Instance是对NativeToJsBridge的封装，NativeToJsBridge是对JSIExecutor的封装。</p>
</blockquote>
<blockquote>
<p>上述源码里用到一个叫prepareBridge的dispatch_group_t，虽然名称叫prepareBridge，但其实是一个dispatch_group_t。dispatch_group_t和dispatch_group_notify联合使用保证异步代码同步按顺序执行，也就是被添加到group中的任务都做完了之后再执行notify中的任务(但group中的多个任务的执行顺序是无序的)。有很多初始化工作是异步并行的，运行JS源码是在所有准备工作之后才能进行，所以用了dispatch_group_t和dispatch_group_notify机制来确保这个问题。</p>
</blockquote>
<p>在上述源码里我们看到了一个名为<strong>ensureOnJavaScriptThread:</strong>的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">[self ensureOnJavaScriptThread:^&#123;</span><br><span class="line">[weakSelf _initializeBridge:executorFactory];</span><br><span class="line">dispatch_group_leave(prepareBridge);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>看名字就知道，ensureOnJavaScriptThread:是RCTCxxBridge里专门将block放在JS线程中执行的方法。他的目的就是确保待执行的block能在JS线程执行，所以他接收一个block作为参数，然后判断当前线程是否是先前创建的JS线程，如果是则立即在JS线程同步执行block，否则切换到JS线程执行block。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)ensureOnJavaScriptThread:(dispatch_block_t)block</span><br><span class="line">&#123;</span><br><span class="line">if ([NSThread currentThread] == _jsThread) &#123;</span><br><span class="line">[self _tryAndHandleError:block];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self performSelector:@selector(_tryAndHandleError:)</span><br><span class="line">onThread:_jsThread</span><br><span class="line">withObject:block</span><br><span class="line">waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家常说JS是单线程的，在RN里就是这样的。native侧创建了一个专门服务于JS的线程，然后绑定了一个runloop不让这个JS线程退出，后续JS代码都是在这个线程里执行。</p>
<p>刚才上面只是穿插介绍了ensureOnJavaScriptThread的作用。回过头来看start方法中ensureOnJavaScriptThread:的block主要是在JS线程执行了weakSelf _initializeBridge:executorFactory; 接下来看下_initializeBridge:到底做了哪些事情，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span><br><span class="line">&#123;</span><br><span class="line">RCTAssertJSThread();</span><br><span class="line">__weak RCTCxxBridge *weakSelf = self;</span><br><span class="line">_jsMessageThread = std::make_shared&lt;RCTMessageThread&gt;([NSRunLoop currentRunLoop], ^(NSError *error) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">[weakSelf handleError:error];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (_reactInstance) &#123;</span><br><span class="line">[self _initializeBridgeLocked:executorFactory];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_initializeBridgeLocked:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// This is async, but any calls into JS are blocked by the m_syncReady CV in Instance</span><br><span class="line">_reactInstance-&gt;initializeBridge(</span><br><span class="line">std::make_unique&lt;RCTInstanceCallback&gt;(self),</span><br><span class="line">executorFactory,</span><br><span class="line">_jsMessageThread,</span><br><span class="line">[self _buildModuleRegistryUnlocked]);</span><br><span class="line">_moduleRegistryCreated = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，通过assert不难看出，RCTCxxBridge的 _initializeBridge:方法确实是在JSThread中调用的。且 _initializeBridge:方法主要做了2件事：</p>
<p>1.创建一个名为_jsMessageThread的RCTMessageThread实例，并被RCTCxxBridge持有（可以看出messageThread实际上是由runloop实现的）</p>
<p>2.调用_initializeBridgeLocked:传入RCTExecutorFactory初始化bridge（nativeToJsBridge实例）</p>
<p>_initializeBridgeLocked:的实现更简单，_initializeBridgeLocked:内部调用了_reactInstance的initializeBridge方法继续初始化bridge（NativeToJsBrige实例）。如注释所述，这个方法是异步调用的，但是所有经由_reactInstance实例对JS方法的调用都会被Instance中名为m_syncReady这个成员变量给锁住。</p>
<p>此处先忽略上面的第四个参数self _buildModuleRegistryUnlocked ，继续看_reactInstance的initializeBridge方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Instance.cpp</span><br><span class="line"></span><br><span class="line">void Instance::initializeBridge(</span><br><span class="line">std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">callback_ = std::move(callback);</span><br><span class="line">moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line">jsQueue-&gt;runOnQueueSync([this, &amp;jsef, jsQueue]() mutable &#123;</span><br><span class="line">nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line"></span><br><span class="line">std::lock_guard&lt;std::mutex&gt; lock(m_syncMutex);</span><br><span class="line">m_syncReady = true;</span><br><span class="line">m_syncCV.notify_all();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，在jsQueue（MessageQueueThread）线程里最主要创建了native-&gt;JS的桥，即nativeToJsBridge_。然后instance持有了这个nativeToJsBridge_以及其他2个外部传进来的参数 callback、moduleRegistry。至此Instance的初始化就结束了。下面我们来看一下这四个参数：</p>
<p>第一个参数是InstanceCallback类型的回调，用于底层执行结束后往上层回调，实际上调用方传递的是self，即RCTCxxBridge实例。</p>
<p>第二个参数是JSExecutorFactory，即生产JSExecutor的工厂实例。Instance内部会使用这个facotry获得一个JSExecutor实例。</p>
<p>第三个参数就是我们在外面创建的MessageueueThread。</p>
<p>第四个参数moduleRegistry是ModuleRegistry类型的实例。moduleRegistry里面包含了所有的Native Module信息，即RCTModuleData。即将前面生成的所有RCTModuleData传给了_reactInstance。至此我们知道self _buildModuleRegistryUnlocked实际上是返回了一个RCTmoduleRegistry实例。</p>
<p>下面简单介绍后3个参数：</p>
<h2 id="JSExecutorFactory"><a href="#JSExecutorFactory" class="headerlink" title="JSExecutorFactory"></a>JSExecutorFactory</h2><p>JSExecutorFactory，顾名思义用于生产JSExecutor实例，JSExecutor用于执行JS，也是JS和Native之间的桥梁。无论是Native call JS还是JS call Native，JSExecutor都起到了至关重要的作用。生产环境下使用的是JSCExecutorFactory，返回JSIExecutor用于执行JS，开发环境使用的是RCTObjcExecutorFactory，返回RCTObjcExecutor通过websocket链接chrome执行JS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JSExecutor.h</span><br><span class="line"></span><br><span class="line">class JSExecutorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">virtual std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span><br><span class="line">std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) = 0;</span><br><span class="line">virtual ~JSExecutorFactory() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="MessageQueueThread"><a href="#MessageQueueThread" class="headerlink" title="MessageQueueThread"></a>MessageQueueThread</h2><p>MessageQueueThread类型对象用于提供队列执行。这里是由RCTMessageThread来实现，内部用的是CFRunLoop来实现。</p>
<p>除RCTMessageThread之外，另一个实现是DispatchMessageQueueThread，我们不做详细介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// MessageQueueThread.h</span><br><span class="line"></span><br><span class="line">namespace facebook &#123;</span><br><span class="line">namespace react &#123;</span><br><span class="line"></span><br><span class="line">class MessageQueueThread &#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~MessageQueueThread() &#123;&#125;</span><br><span class="line">virtual void runOnQueue(std::function&lt;void()&gt;&amp;&amp;) = 0;</span><br><span class="line">virtual void runOnQueueSync(std::function&lt;void()&gt;&amp;&amp;) = 0;</span><br><span class="line">virtual void quitSynchronous() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ModuleRegistry"><a href="#ModuleRegistry" class="headerlink" title="ModuleRegistry"></a>ModuleRegistry</h2><p>上面说了moduleRegistry中包括了所有native module信息，即RCTModuleData。这还要从我们刚才忽略的self _buildModuleRegistryUnlocked方法说起，_buildModuleRegistryUnlocked方法主要负责构建一个RCTModuleRegistry实例并返回，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (std::shared_ptr&lt;ModuleRegistry&gt;)_buildModuleRegistryUnlocked</span><br><span class="line">&#123;</span><br><span class="line">__weak __typeof(self) weakSelf = self;</span><br><span class="line">auto registry = std::make_shared&lt;ModuleRegistry&gt;(</span><br><span class="line">createNativeModules(_moduleDataByID, self, _reactInstance),</span><br><span class="line">moduleNotFoundCallback);</span><br><span class="line"></span><br><span class="line">return registry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RCTCxxUtils.mm</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; createNativeModules(NSArray&lt;RCTModuleData *&gt; *modules, RCTBridge *bridge, const std::shared_ptr&lt;Instance&gt; &amp;instance)</span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; nativeModules;</span><br><span class="line">for (RCTModuleData *moduleData in modules) &#123;</span><br><span class="line">if ([moduleData.moduleClass isSubclassOfClass:[RCTCxxModule class]]) &#123;</span><br><span class="line">nativeModules.emplace_back(std::make_unique&lt;CxxNativeModule&gt;(</span><br><span class="line">instance,</span><br><span class="line">[moduleData.name UTF8String],</span><br><span class="line">// moduleData.instance就是native module实例对象</span><br><span class="line">[moduleData] &#123; return [(RCTCxxModule *)(moduleData.instance) createModule]; &#125;,</span><br><span class="line">std::make_shared&lt;DispatchMessageQueueThread&gt;(moduleData)));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">nativeModules.emplace_back(std::make_unique&lt;RCTNativeModule&gt;(bridge, moduleData));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nativeModules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，上面使用_moduleDataByID初始化并返回了一个ModuleRegistry实例。_moduleDataByID是一个含有若干个RCTModuleData对象的数组。在<a href="https://cloud.tencent.com/developer/article/1597259" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1597259</a>中我们介绍了_moduleDataByID中的RCTModuleData实际上就是在程序启动后load各个class的时候被收集的。有必要提一下，上面源码中的moduleData.instance其实就是native module的实例对象。通过如下代码可窥见一斑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// RCTModuleData.mm</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithModuleClass:(Class)moduleClass</span><br><span class="line">bridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">return [self initWithModuleClass:moduleClass</span><br><span class="line">moduleProvider:^id&lt;RCTBridgeModule&gt;&#123; return [moduleClass new]; &#125;</span><br><span class="line">bridge:bridge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithModuleClass:(Class)moduleClass</span><br><span class="line">moduleProvider:(RCTBridgeModuleProvider)moduleProvider</span><br><span class="line">bridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">_bridge = bridge;</span><br><span class="line">_moduleClass = moduleClass;</span><br><span class="line">_moduleProvider = [moduleProvider copy];</span><br><span class="line">[self setUp];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithModuleInstance:(id&lt;RCTBridgeModule&gt;)instance</span><br><span class="line">bridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">_bridge = bridge;</span><br><span class="line">_instance = instance;</span><br><span class="line">_moduleClass = [instance class];</span><br><span class="line">[self setUp];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，RN中Instance实例（_reactInstance）的初始化已经介绍完了，接下来介绍NativeToJSBridge。为什么要介绍NativeToJsBridge？因为我们上面说了Instance是对NativeToJSBridge的封装，就像UIView是对CALayer的封装一样，可见NativeToJSBridge比Instance更加接近底层（实际JSExecutor比NativeToJSBridge更加底层，我们后面详细的说明）。</p>
<h1 id="NativeToJSBridge"><a href="#NativeToJSBridge" class="headerlink" title="NativeToJSBridge"></a>NativeToJSBridge</h1><p><strong>NativeToJsBridge的主要作用是负责管理所有native对JS的调用，并且也管理了executor们和他们的线程。NativeToJsBridge的所有函数可以在任意线程被调用。除非某些方法是为了同步加载Application Script，否则所有的方法都是在JSQueue线程排队等候执行的，且这些函数会被立即返回。</strong>这也说明大部分Native call JS的方法都是在jsQueue这个线程执行的，而jsQueue实际上就是messageQueueThread。</p>
<p>在上面Instance::initializeBridge函数中，我们知道Instance创建了一个名为nativeToJsBridge_的NativeToJSBridge的实例并被Instance实例持有。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Instance.cpp</span><br><span class="line"></span><br><span class="line">void Instance::initializeBridge(</span><br><span class="line">std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">callback_ = std::move(callback);</span><br><span class="line">moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line">jsQueue-&gt;runOnQueueSync([this, &amp;jsef, jsQueue]() mutable &#123;</span><br><span class="line">// 初始化nativeToJsBridge_成员变量</span><br><span class="line">nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出nativeToJsBirdge的类型是NativeToJsBridge。下面我们来看下NativeToJsBridge类的具体定义。</p>
<h2 id="NativeToJSBridge定义"><a href="#NativeToJSBridge定义" class="headerlink" title="NativeToJSBridge定义"></a>NativeToJSBridge定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// NativeToJsBridge.cpp</span><br><span class="line"></span><br><span class="line">class NativeToJsBridge &#123;</span><br><span class="line">public:</span><br><span class="line">friend class JsToNativeBridge;</span><br><span class="line"></span><br><span class="line">// 必须在主线程调用</span><br><span class="line">NativeToJsBridge(</span><br><span class="line">JSExecutorFactory* jsExecutorFactory,</span><br><span class="line">std::shared_ptr&lt;ModuleRegistry&gt; registry,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">std::shared_ptr&lt;InstanceCallback&gt; callback);</span><br><span class="line">virtual ~NativeToJsBridge();</span><br><span class="line"></span><br><span class="line">// 传入module ID、method ID、参数用于在JS侧执行一个函数</span><br><span class="line">void callFunction(std::string&amp;&amp; module, std::string&amp;&amp; method, folly::dynamic&amp;&amp; args);</span><br><span class="line"></span><br><span class="line">// 通过callbackId调用JS侧的回调</span><br><span class="line">void invokeCallback(double callbackId, folly::dynamic&amp;&amp; args);</span><br><span class="line"></span><br><span class="line">// 开始执行JS application. 如果bundleRegistry非空，就会使用RAM的方式 读取JS源码文件</span><br><span class="line">// 否则就假定 startupCode 已经包含了所有的JS源码文件</span><br><span class="line">void loadApplication(</span><br><span class="line">std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; startupCode,</span><br><span class="line">std::string sourceURL);</span><br><span class="line">void loadApplicationSync(</span><br><span class="line">std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; startupCode,</span><br><span class="line">std::string sourceURL);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">std::shared_ptr&lt;JsToNativeBridge&gt; m_delegate;</span><br><span class="line">std::unique_ptr&lt;JSExecutor&gt; m_executor;</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; m_executorMessageQueueThread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上，NativeToJsBridge是一个C++类，它主要有如下3个重要的成员变量：</p>
<ul>
<li><strong><jstonativebridge> m_delegate</jstonativebridge></strong></li>
</ul>
<p>m_delegate是JsToNativeBridge类型的引用，主要用于JS call Native</p>
<ul>
<li><strong><jsexecutor> m_executor</jsexecutor></strong></li>
</ul>
<p> JSExecutor类型引用，主要用于执行Native call JS，实际上生产环境使用的是JSIExecutor；调试环境使用的是RCTObjcExecutor</p>
<ul>
<li><strong><messagequeuethread> m_executorMessageQueueThread</messagequeuethread></strong></li>
</ul>
<p>MessageQueueThread类型引用，内部是由runloop实现的，由外部传递，用于队列管理。这里的外部传递是指m_executorMessageQueueThread并非NativeToJsBridge自己初始化的，而是作为初始化NativeToJsBridge的参数由上层传递进来的。如果你还记得NativeToJsBridge是在Instance::initializeBridge中初始化的，那么你就知道这个m_executorMessageQueueThread最终起源于RCTCxxBridge中的_jsMessageThread，进而由一步一步的函数调用，穿山越岭传递进来的。所以，<strong>NativeToJsBridge的m_executorMessageQueueThread就是  了RCTCxxBridge的_jsMessageThread</strong>。</p>
<p>除了以上3个关键的属性之外，NativeToJsBridge还定义了4个函数：</p>
<ul>
<li><strong>void callFunction(std::string&amp;&amp; module, std::string&amp;&amp; method, folly::dynamic&amp;&amp; args);</strong></li>
</ul>
<p>这个函数的意义就是通过module ID和method ID以及参数去调用JS方法</p>
<ul>
<li><strong>void invokeCallback(double callbackId, folly::dynamic&amp;&amp; args);</strong></li>
</ul>
<p>这个函数的意义就是通过callbackId和参数触发一个JS的回调。通常是JS call Native method之后，native把一些异步的执行结果再以callback的形式回调给JS。</p>
<ul>
<li><strong>void loadApplication(</strong></li>
</ul>
<p><strong>std::unique_ptr<rambundleregistry> bundleRegistry,</rambundleregistry></strong><br><strong>std::unique_ptr<const jsbigstring> startupCode,</const></strong><br><strong>std::string sourceURL);</strong></p>
<p>这个方法的作用是执行JS代码，他还有一个兄弟叫做loadApplicationSync，顾名思义，他兄弟是一个同步函数，所以他自己就是异步执行JS代码。</p>
<h2 id="NativeToJsBridge构造函数"><a href="#NativeToJsBridge构造函数" class="headerlink" title="NativeToJsBridge构造函数"></a><strong>NativeToJsBridge构造函数</strong></h2><p>上面说了NativeBridge的3个关键属性和4个关键方法，接下来我们说下他的构造函数，接触过C++的开发者应该知道，C++中类的构造函数和类同名，如下是NativeToJsBridge的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeToJsBridge::NativeToJsBridge(</span><br><span class="line">JSExecutorFactory *jsExecutorFactory,</span><br><span class="line">std::shared_ptr&lt;ModuleRegistry&gt; registry,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">std::shared_ptr&lt;InstanceCallback&gt; callback)</span><br><span class="line">: m_destroyed(std::make_shared&lt;bool&gt;(false)),</span><br><span class="line">m_delegate(std::make_shared&lt;JsToNativeBridge&gt;(registry, callback)),</span><br><span class="line">m_executor(jsExecutorFactory-&gt;createJSExecutor(m_delegate, jsQueue)),</span><br><span class="line">m_executorMessageQueueThread(std::move(jsQueue)),</span><br><span class="line">m_inspectable(m_executor-&gt;isInspectable()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们在Instance::initializeBridge中就已经调用过NativeToJsBridge的构造函数创建了一个NativeToJsBridge实例并被赋值给Instance实例的成员变量nativeToJsBridge_。在NativeToJSBridge构造函数的后面有一个初始化列表，其中registry和callback作为入参生成了一个JsToNativeBridge类型实例赋值给m_delegate。jsExecutorFactory又通过m_delegate和jsQueue生产了一个executor赋值给m_executor（m_delegate最终是给m_executor使用的，在生产环境下，jsQueue对于executor也是无用的），m_executorMessageQueueThread最后指向了jsQueue。</p>
<h1 id="JSIExecutor"><a href="#JSIExecutor" class="headerlink" title="JSIExecutor"></a>JSIExecutor</h1><p><strong>和Instance、NativeToJsBridge一样，JSIExecutor主要用来Native call JS，但他是比Instance和NativeToJsBridge更深层次的一个核心类，换句话说，我们可以把NativeToJsBridge理解为JSIExecutor的包装（而Instance又是对NativeToJsBridge的包装），对Instance的调用最终都会走到NativeToJsBridge，对NativeToJsBridge的调用最终都会走到JSIExecutor，比如getJavaScriptContext、callFunction、invokeCallback这些方法。他们的调用顺序是Instance-&gt;NativeToJsBridge-&gt;JSIExecutor。</strong>上面我们说了，在NativeToJsBridge的构造函数中jsExecutorFactory使用JsToNativeBridge实例m_delegate和jsQueue创建了m_executor（实际上生产环境下只用了m_delegate）。这里我们主要以生产环境的JSIExecutor为例介绍。调试模式下请参考RCTObjcExecutor，他们都继承自JSExecutor。下面是两种环境下executor的创建方式，生产环境的JSIExecutor通过JSCExecutorFactory生产，调试模式下的RCTObjcExecutor通过RCTObjcExecutorFactory生产，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// JSCExecutorFactory.mm</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;JSExecutor&gt; JSCExecutorFactory::createJSExecutor(</span><br><span class="line">std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; __unused jsQueue) &#123;</span><br><span class="line"></span><br><span class="line">return folly::make_unique&lt;JSIExecutor&gt;(</span><br><span class="line">facebook::jsc::makeJSCRuntime(),</span><br><span class="line">delegate,</span><br><span class="line">JSIExecutor::defaultTimeoutInvoker,</span><br><span class="line">std::move(installBindings));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RCTObjcExecutor.mm</span><br><span class="line">std::unique_ptr&lt;JSExecutor&gt; RCTObjcExecutorFactory::createJSExecutor(</span><br><span class="line">std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) &#123;</span><br><span class="line">return std::unique_ptr&lt;JSExecutor&gt;(</span><br><span class="line">new RCTObjcExecutor(m_jse, m_errorBlock, jsQueue, delegate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSIExecutor主要的几个关键属性：</p>
<ul>
<li><strong><a href="jsi::Runtime" target="_blank" rel="noopener">jsi::Runtime</a> runtime_</strong></li>
</ul>
<p>Runtime类型指针，代表JS的运行时。这是一个抽象类，其实际上是由JSCRuntime来实现的。JSCRuntime实现了<a href="jsi::Runtime" target="_blank" rel="noopener">jsi::Runtime</a>接口，提供了创建JS上下文的功能，同时可以执行JS。如下是JSCRuntime的evaluateJavaScript方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// JSCRuntime.cpp</span><br><span class="line"></span><br><span class="line">jsi::Value JSCRuntime::evaluateJavaScript(</span><br><span class="line">const std::shared_ptr&lt;const jsi::Buffer&gt; &amp;buffer,</span><br><span class="line">const std::string&amp; sourceURL) &#123;</span><br><span class="line">std::string tmp(</span><br><span class="line">reinterpret_cast&lt;const char*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">JSStringRef sourceURLRef = nullptr;</span><br><span class="line">if (!sourceURL.empty()) &#123;</span><br><span class="line">sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">&#125;</span><br><span class="line">JSValueRef exc = nullptr;</span><br><span class="line">JSValueRef res = JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, 0, &amp;exc);</span><br><span class="line"></span><br><span class="line">return createValue(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><executordelegate> delegate_</executordelegate></strong></li>
</ul>
<p>ExecutorDelegate类型的指针，这里的ExecutorDelegate是抽象类，实际是由JsToNativeBridge实现的。也即JSIExecutor引用了JsToNativeBridge实例。还记得NativeToJsBridge中的JsToNativeBridge类型的成员变量m_delegate吗？其实这里的delegate_就是NativeToJsBridge中的m_delegate。</p>
<ul>
<li><strong><jsinativemodules> nativeModules_</jsinativemodules></strong></li>
</ul>
<p>JSINativeModules由上层传入的ModuleRegistry构造而成，同时会将ModuleRegistry中包含的本地模块配置信息通过”__fbGenNativeModule”保存到JS端。</p>
<p>JSINativeModules有个getModule方法，getModule方法内又调用了 createModule方法，createModule方法生成了module信息，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// JSINativeModules.cpp</span><br><span class="line"></span><br><span class="line">Value JSINativeModules::getModule(Runtime&amp; rt, const PropNameID&amp; name) &#123;</span><br><span class="line">std::string moduleName = name.utf8(rt);</span><br><span class="line">// 调用createModule方法</span><br><span class="line">auto module = createModule(rt, moduleName);</span><br><span class="line">auto result =</span><br><span class="line">m_objects.emplace(std::move(moduleName), std::move(*module)).first;</span><br><span class="line">return Value(rt, result-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">folly::Optional&lt;Object&gt; JSINativeModules::createModule(</span><br><span class="line">Runtime&amp; rt,</span><br><span class="line">const std::string&amp; name) &#123;</span><br><span class="line"></span><br><span class="line">if (!m_genNativeModuleJS) &#123;</span><br><span class="line">// runtime获取名为__fbGenNativeModule的函数指针赋值给m_genNativeModuleJS</span><br><span class="line">// JS端的函数__fbGenNativeModule调用最终就会走到这里。</span><br><span class="line">m_genNativeModuleJS =</span><br><span class="line">rt.global().getPropertyAsFunction(rt, &quot;__fbGenNativeModule&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto result = m_moduleRegistry-&gt;getConfig(name);</span><br><span class="line">// 调用m_genNativeModuleJS函数，即__fbGenNativeModule</span><br><span class="line">Value moduleInfo = m_genNativeModuleJS-&gt;call(</span><br><span class="line">rt,</span><br><span class="line">valueFromDynamic(rt, result-&gt;config),</span><br><span class="line">static_cast&lt;double&gt;(result-&gt;index));</span><br><span class="line"></span><br><span class="line">folly::Optional&lt;Object&gt; module(</span><br><span class="line">moduleInfo.asObject(rt).getPropertyAsObject(rt, &quot;module&quot;));</span><br><span class="line">// 返回生成的module</span><br><span class="line">return module;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那到这里你会问JSINativeModules负责createModule并提供了可以访问某个module的接口getModule。那是谁调用的JSINativeModules的getModule呢？全局搜索getModule不难发现，getModule是在一个名为NativeModuleProxy的get方法里调用的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// JSIExecutor.cpp</span><br><span class="line"></span><br><span class="line">class JSIExecutor::NativeModuleProxy : public jsi::HostObject &#123;</span><br><span class="line">public:</span><br><span class="line">// 构造函数 JSIExecutor实例作为NativeModuleProxy构造函数的入参</span><br><span class="line">NativeModuleProxy(JSIExecutor &amp;executor) : executor_(executor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// NativeModuleProxy 的 get方法 用于获取native module信息</span><br><span class="line">Value get(Runtime &amp;rt, const PropNameID &amp;name) override &#123;</span><br><span class="line">return executor_.nativeModules_.getModule(rt, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么NativeModuleProxy这个C++类又是在哪里使用的呢？全局搜索NativeModuleProxy，你会发现只有一个地方再使用NativeModuleProxy，就是JSIExecutor的loadApplicationScript方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// JSIExecutor.cpp </span><br><span class="line"></span><br><span class="line">void JSIExecutor::loadApplicationScript(</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; script,</span><br><span class="line">std::string sourceURL) &#123;</span><br><span class="line"></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">*runtime_,</span><br><span class="line">&quot;nativeModuleProxy&quot;,</span><br><span class="line">Object::createFromHostObject(</span><br><span class="line">*runtime_, std::make_shared&lt;NativeModuleProxy&gt;(*this)));</span><br><span class="line"></span><br><span class="line">// 此处省略若干行代码...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，上面出镜率最高的代码就是<strong>runtime_-&gt;global().setProperty( //… ); runtime是一个JSCRuntime类型对象，通过调用rumtime_-&gt;global()获得一个全局的global对象。然后又通过setProperty方法给global对象设置了一个名为</strong>nativeModuleProxy的对象。日后（JS侧的）global对象通过”nativeModuleProxy”这个名字即可访问到（native侧的）NativeModuleProxy，这听起来像是一句废话。说到这里，我们不得不说一下JS侧的global.nativeModuleProxy，我们会诧异于在native侧和JS侧的global中都存在nativeModuleProxy变量，其实这不是巧合，本质上，JS侧的global.nativeModuleProxy就是native侧的nativeModuleProxy。换句话说，我们在JS侧的NativeModules对应的就是native侧的nativeModuleProxy。JS侧代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 源码位置：react-native/Libraries/BatchedBridge/NativeModules.js</span><br><span class="line"></span><br><span class="line">let NativeModules: &#123;[moduleName: string]: Object&#125; = &#123;&#125;;</span><br><span class="line">if (global.nativeModuleProxy) &#123;</span><br><span class="line">NativeModules = global.nativeModuleProxy;</span><br><span class="line">&#125; else if (!global.nativeExtensions) &#123;</span><br><span class="line">const bridgeConfig = global.__fbBatchedBri</span><br></pre></td></tr></table></figure>

<p><strong>通过上述JS代码可以看出，JS侧的NativeModules == JS侧的global.nativeModuleProxy == native侧NativeModuleProxy。</strong></p>
<p>JS侧对NativeModules的调用都会经由native侧的NativeModuleProxy后进而调用到JSINativeModules的的createModule这个实例方法返回了moduleName对应的module config。值得一提的是，在createModule方法中，还调用了一个名为“__fbGenNativeModule”的JS方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// JSINativeModules.cpp</span><br><span class="line">// JSINativeModules::createModule方法中</span><br><span class="line"></span><br><span class="line">if (!m_genNativeModuleJS) &#123;</span><br><span class="line">m_genNativeModuleJS =</span><br><span class="line">rt.global().getPropertyAsFunction(rt, &quot;__fbGenNativeModule&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value moduleInfo = m_genNativeModuleJS-&gt;call(</span><br><span class="line">rt,</span><br><span class="line">valueFromDynamic(rt, result-&gt;config),</span><br><span class="line">static_cast&lt;double&gt;(result-&gt;index));</span><br></pre></td></tr></table></figure>

<p>通过runtime获取JS全局对象global，接着通过方法名“__fbGenNativeModule”从golbal实例中获取这个JS方法指针，然后进行调用。当然，要想在native侧可以调用到这个JS方法，前提是需要在JS侧对这个方法进行定义。如下是这个方法在JS侧的源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 源码位置：react-native/Libraries/BatchedBridge/NativeModules.js</span><br><span class="line"></span><br><span class="line">function genModule(</span><br><span class="line">config: ?ModuleConfig,</span><br><span class="line">moduleID: number,</span><br><span class="line">): ?&#123;name: string, module?: Object&#125; &#123;</span><br><span class="line"></span><br><span class="line">const [moduleName, constants, methods, promiseMethods, syncMethods] = config;</span><br><span class="line"></span><br><span class="line">const module = &#123;&#125;;</span><br><span class="line">methods &amp;&amp;</span><br><span class="line">methods.forEach((methodName, methodID) =&gt; &#123;</span><br><span class="line">const isPromise =</span><br><span class="line">promiseMethods &amp;&amp; arrayContains(promiseMethods, methodID);</span><br><span class="line">const isSync = syncMethods &amp;&amp; arrayContains(syncMethods, methodID);</span><br><span class="line">const methodType = isPromise ? &apos;promise&apos; : isSync ? &apos;sync&apos; : &apos;async&apos;;</span><br><span class="line">module[methodName] = genMethod(moduleID, methodID, methodType);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return &#123;name: moduleName, module&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出genModule到全局变量global上以便native可以调用</span><br><span class="line">global.__fbGenNativeModule = genModule;</span><br></pre></td></tr></table></figure>

<p>上面JS源码先是定义了一个名为genModule的函数，然后又把这个函数挂载到了全局变量global的”__fbGenNativeModule”上，以便作为一个可以全局访问的全局函数，这样做的目的是方便在native侧调用。所以，__fbGenNativeModule这个函数指代的就是gemModule。</p>
<p>到这里JSIExecutor的初始化完成了，这样和JS之间的桥梁就建好了，以后Native call JS都会先后经由Instance、NativeToJSBridge、JSIExecutor最终到达JS。</p>
<p>下图描述了bridge初始化的方法调用时序图和涉及到的主要类：</p>
<p><img src="/2020/03/04/详解ReactNative初始化和通信机制/RNbridge%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="RN bridge初始化"></p>
<h1 id="加载JS代码"><a href="#加载JS代码" class="headerlink" title="加载JS代码"></a>加载JS代码</h1><p>然后，我们不要忘了，以上这一大段篇幅只是初始化了RCTCxxBridge中的_reactInstance以及instance背后的NativeToJsBridge、JSIExecutor。我们还记得RCTCxxBridge的start方法中，除了初始化_reactInstance、NativeToJSBridge、JSIExecutor之外，与之同时进行的还有加载JS源码，jsBundle的加载是通过RCTJavaScriptLoader进行的。当初始化工作和JS源码加载都完成后，就会执行JS源码。让我们来回顾一下RCTCxxBridge.mm中的start方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line"></span><br><span class="line">// 此处省略若干行...</span><br><span class="line"></span><br><span class="line">// 1. 初始化native module</span><br><span class="line">dispatch_group_t prepareBridge = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">// 2. 在JS线程初始化_reactInstance、RCTMessageThread、nativeToJsBridge、JSCExecutor</span><br><span class="line">dispatch_group_enter(prepareBridge);</span><br><span class="line">[self ensureOnJavaScriptThread:^&#123;</span><br><span class="line">[weakSelf _initializeBridge:executorFactory];</span><br><span class="line">dispatch_group_leave(prepareBridge);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3. 异步加载JS代码</span><br><span class="line">dispatch_group_enter(prepareBridge);</span><br><span class="line">__block NSData *sourceCode;</span><br><span class="line">[self loadSource:^(NSError *error, RCTSource *source) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">[weakSelf handleError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceCode = source.data;</span><br><span class="line">dispatch_group_leave(prepareBridge);</span><br><span class="line">&#125; onProgress:^(RCTLoadingProgress *progressData) &#123;</span><br><span class="line">// 展示加载bundle 的 loadingView </span><br><span class="line">#if RCT_DEV &amp;&amp; __has_include(&lt;React/RCTDevLoadingView.h&gt;)</span><br><span class="line">RCTDevLoadingView *loadingView = [weakSelf moduleForName:RCTBridgeModuleNameForClass([RCTDevLoadingView class])</span><br><span class="line">lazilyLoadIfNecessary:NO];</span><br><span class="line">[loadingView updateProgress:progressData];</span><br><span class="line">#endif</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 4. 等待native moudle 和 JS 代码加载完毕后就执行JS</span><br><span class="line">dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0), ^&#123;</span><br><span class="line">RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">if (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">[strongSelf executeSourceCode:sourceCode sync:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，在初始化_reactInstance完成之后，还有异步load JS源码以及执行源码的工作（实际上，因为dispatch_group_t的原因，初始化_reactInstance和load JS源码是并发执行的，但只有在两者工作都完毕后才去执行JS代码）。本节我们将会介绍JS代码的加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)loadSource:(RCTSourceLoadBlock)_onSourceLoad onProgress:(RCTSourceLoadProgressBlock)onProgress</span><br><span class="line">&#123;</span><br><span class="line">// 发送通知 将要加载JS代码</span><br><span class="line">NSNotificationCenter *center = [NSNotificationCenter defaultCenter];</span><br><span class="line">[center postNotificationName:RCTBridgeWillDownloadScriptNotification object:_parentBridge];</span><br><span class="line">// JS代码加载完成的回调</span><br><span class="line">RCTSourceLoadBlock onSourceLoad = ^(NSError *error, RCTSource *source) &#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *userInfo = @&#123;</span><br><span class="line">RCTBridgeDidDownloadScriptNotificationSourceKey: source ?: [NSNull null],</span><br><span class="line">RCTBridgeDidDownloadScriptNotificationBridgeDescriptionKey: self-&gt;_bridgeDescription ?: [NSNull null],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[center postNotificationName:RCTBridgeDidDownloadScriptNotification object:self-&gt;_parentBridge userInfo:userInfo];</span><br><span class="line"></span><br><span class="line">_onSourceLoad(error, source);</span><br><span class="line">&#125;;</span><br><span class="line">// 通知delegate</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(loadSourceForBridge:onProgress:onComplete:)]) &#123;</span><br><span class="line">[self.delegate loadSourceForBridge:_parentBridge onProgress:onProgress onComplete:onSourceLoad];</span><br><span class="line">&#125; else if ([self.delegate respondsToSelector:@selector(loadSourceForBridge:withBlock:)]) &#123;</span><br><span class="line">[self.delegate loadSourceForBridge:_parentBridge withBlock:onSourceLoad];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 加载JS代码</span><br><span class="line">__weak RCTCxxBridge *weakSelf = self;</span><br><span class="line">[RCTJavaScriptLoader loadBundleAtURL:self.bundleURL onProgress:onProgress onComplete:^(NSError *error, RCTSource *source) &#123;</span><br><span class="line">onSourceLoad(error, source);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，上述代码中通过调用RCTJavaScriptLoader的类方法loadBundleAtURL:onProgress:onComplete加载JS bundle。如下是源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// RCTJavaScriptLoader.mm</span><br><span class="line"></span><br><span class="line">+ (void)loadBundleAtURL:(NSURL *)scriptURL onProgress:(RCTSourceLoadProgressBlock)onProgress onComplete:(RCTSourceLoadBlock)onComplete</span><br><span class="line">&#123;</span><br><span class="line">int64_t sourceLength;</span><br><span class="line">NSError *error;</span><br><span class="line">// 尝试 同步加载JS bundle</span><br><span class="line">NSData *data = [self attemptSynchronousLoadOfBundleAtURL:scriptURL</span><br><span class="line">runtimeBCVersion:JSNoBytecodeFileFormatVersion</span><br><span class="line">sourceLength:&amp;sourceLength</span><br><span class="line">error:&amp;error];</span><br><span class="line">if (data) &#123;</span><br><span class="line">onComplete(nil, RCTSourceCreate(scriptURL, data, sourceLength));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const BOOL isCannotLoadSyncError =</span><br><span class="line">[error.domain isEqualToString:RCTJavaScriptLoaderErrorDomain]</span><br><span class="line">&amp;&amp; error.code == RCTJavaScriptLoaderErrorCannotBeLoadedSynchronously;</span><br><span class="line">// 尝试 异步加载JS bundle</span><br><span class="line">if (isCannotLoadSyncError) &#123;</span><br><span class="line">attemptAsynchronousLoadOfBundleAtURL(scriptURL, onProgress, onComplete);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">onComplete(error, nil);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，上面一段代码还是很清晰的，主要做了2件事：</p>
<p>1.尝试同步加载JS bundle，加载成功就执行onComplete回调</p>
<p>2.如果不能同步加载则尝试异步加载JS bundle，否则直接onComplete</p>
<p>那么什么情况下可以同步加载JS bundle？答案是如果要加载的bundle是本地预置的或是已经下载好的，那么就可以同步加载，否则只能异步download。</p>
<p>下面我们分别来看下同步加载bundle和异步加载bundle的实现。</p>
<h2 id="同步加载bundle"><a href="#同步加载bundle" class="headerlink" title="同步加载bundle"></a>同步加载bundle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// RCTJavaScriptLoader.mm</span><br><span class="line"></span><br><span class="line">+ (NSData *)attemptSynchronousLoadOfBundleAtURL:(NSURL *)scriptURL</span><br><span class="line">runtimeBCVersion:(int32_t)runtimeBCVersion</span><br><span class="line">sourceLength:(int64_t *)sourceLength</span><br><span class="line">error:(NSError **)error</span><br><span class="line">&#123;</span><br><span class="line">// 如果bundle不在本地，那么就不能同步加载</span><br><span class="line">if (!scriptURL.fileURL) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">*error = [NSError errorWithDomain:RCTJavaScriptLoaderErrorDomain</span><br><span class="line">code:RCTJavaScriptLoaderErrorCannotBeLoadedSynchronously</span><br><span class="line">userInfo:@&#123;NSLocalizedDescriptionKey:</span><br><span class="line">[NSString stringWithFormat:@&quot;Cannot load %@ URLs synchronously&quot;,</span><br><span class="line">scriptURL.scheme]&#125;];</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查前4个字节来判断这个bundle是普通bundle还是RAM bundle</span><br><span class="line">// 如果是RAM bundle，则在前4个字节有一个数字 `(0xFB0BD1E5)`</span><br><span class="line">// RAM bundle相对于普通bundle的好处是当有需要时再去以“懒加载”的形式2把modules注入到JSC</span><br><span class="line">FILE *bundle = fopen(scriptURL.path.UTF8String, &quot;r&quot;);</span><br><span class="line">if (!bundle) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">*error = [NSError errorWithDomain:RCTJavaScriptLoaderErrorDomain</span><br><span class="line">code:RCTJavaScriptLoaderErrorFailedOpeningFile</span><br><span class="line">userInfo:@&#123;NSLocalizedDescriptionKey:</span><br><span class="line">[NSString stringWithFormat:@&quot;Error opening bundle %@&quot;, scriptURL.path]&#125;];</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取header</span><br><span class="line">// 关于fread各个参数的解释： </span><br><span class="line">// __ptr -- 这是指向带有最小尺寸 size*nitems 字节的内存块的指针。</span><br><span class="line">// __size -- 这是要读取的每个元素的大小，以字节为单位。</span><br><span class="line">// __nitems -- 这是元素的个数，每个元素的大小为 size 字节。</span><br><span class="line">// __stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</span><br><span class="line">facebook::react::BundleHeader header;</span><br><span class="line">size_t readResult = fread(&amp;header, sizeof(header), 1, bundle);</span><br><span class="line">fclose(bundle);</span><br><span class="line"></span><br><span class="line">facebook::react::ScriptTag tag = facebook::react::parseTypeFromHeader(header);</span><br><span class="line">switch (tag) &#123;</span><br><span class="line">case facebook::react::ScriptTag::RAMBundle:</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case facebook::react::ScriptTag::String: &#123;</span><br><span class="line">NSData *source = [NSData dataWithContentsOfFile:scriptURL.path</span><br><span class="line">options:NSDataReadingMappedIfSafe</span><br><span class="line">error:error];</span><br><span class="line">if (sourceLength &amp;&amp; source != nil) &#123;</span><br><span class="line">*sourceLength = source.length;</span><br><span class="line">&#125;</span><br><span class="line">return source;</span><br><span class="line">&#125;</span><br><span class="line">case facebook::react::ScriptTag::BCBundle:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct stat statInfo;</span><br><span class="line">if (sourceLength) &#123;</span><br><span class="line">*sourceLength = statInfo.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return [NSData dataWithBytes:&amp;header length:sizeof(header)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，主要做了3件事：</p>
<p>1.如果bundle不在本地，那么就不能同步加载，写入error</p>
<p>2.检查前4个字节来获取这个bundle类型，类型信息存在ScriptTag中</p>
<p>3.返回bundle data</p>
<h2 id="异步加载bundle"><a href="#异步加载bundle" class="headerlink" title="异步加载bundle"></a>异步加载bundle</h2><p>上面介绍了同步加载bundle就是读取本地磁盘预置或预先下载的bundle数据，所以不难判断异步加载bundle就是下载网络上的bundle。下面我们来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// RCTJavaScriptLoader.mm</span><br><span class="line"></span><br><span class="line">static void attemptAsynchronousLoadOfBundleAtURL(NSURL *scriptURL, RCTSourceLoadProgressBlock onProgress, RCTSourceLoadBlock onComplete)</span><br><span class="line">&#123;</span><br><span class="line">if (scriptURL.fileURL) &#123;</span><br><span class="line">// Reading in a large bundle can be slow. Dispatch to the background queue to do it.</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSData *source = [NSData dataWithContentsOfFile:scriptURL.path</span><br><span class="line">options:NSDataReadingMappedIfSafe</span><br><span class="line">error:&amp;error];</span><br><span class="line">onComplete(error, RCTSourceCreate(scriptURL, source, source.length));</span><br><span class="line">&#125;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCTMultipartDataTask *task = [[RCTMultipartDataTask alloc] initWithURL:scriptURL partHandler:^(NSInteger statusCode, NSDictionary *headers, NSData *data, NSError *error, BOOL done) &#123;</span><br><span class="line">if (!done) &#123;</span><br><span class="line">if (onProgress) &#123;</span><br><span class="line">onProgress(progressEventFromData(data));</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证服务器返回的是不是JavaScript</span><br><span class="line">NSString *contentType = headers[@&quot;Content-Type&quot;];</span><br><span class="line">NSString *mimeType = [[contentType componentsSeparatedByString:@&quot;;&quot;] firstObject];</span><br><span class="line">if (![mimeType isEqualToString:@&quot;application/javascript&quot;] &amp;&amp;</span><br><span class="line">![mimeType isEqualToString:@&quot;text/javascript&quot;]) &#123;</span><br><span class="line">NSString *description = [NSString stringWithFormat:@&quot;Expected MIME-Type to be &apos;application/javascript&apos; or &apos;text/javascript&apos;, but got &apos;%@&apos;.&quot;, mimeType];</span><br><span class="line">error = [NSError errorWithDomain:@&quot;JSServer&quot;</span><br><span class="line">code:NSURLErrorCannotParseResponse</span><br><span class="line">userInfo:@&#123;</span><br><span class="line">NSLocalizedDescriptionKey: description,</span><br><span class="line">@&quot;headers&quot;: headers,</span><br><span class="line">@&quot;data&quot;: data</span><br><span class="line">&#125;];</span><br><span class="line">onComplete(error, nil);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 把data包装成source对象</span><br><span class="line">RCTSource *source = RCTSourceCreate(scriptURL, data, data.length);</span><br><span class="line">parseHeaders(headers, source);</span><br><span class="line">onComplete(nil, source);</span><br><span class="line">&#125; progressHandler:^(NSDictionary *headers, NSNumber *loaded, NSNumber *total) &#123;</span><br><span class="line">// Only care about download progress events for the javascript bundle part.</span><br><span class="line">if ([headers[@&quot;Content-Type&quot;] isEqualToString:@&quot;application/javascript&quot;]) &#123;</span><br><span class="line">onProgress(progressEventFromDownloadProgress(loaded, total));</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task startTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，不难看出，异步加载主要做了2件事情：</p>
<p>1.如果bundle是本地文件则异步加载本地bundle</p>
<p>2.如果不是本地bundle则开启一个RCTMultipartDataTask异步下载</p>
<p>以上，是RN所有加载JS代码的逻辑。接下来介绍native是如何执行JS代码的。</p>
<h1 id="执行JS代码"><a href="#执行JS代码" class="headerlink" title="执行JS代码"></a>执行JS代码</h1><p>执行JS代码，终于走到这一步了，还是要从RCTCxxBridge的start方法说起，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">// 此处省略若干行...</span><br><span class="line">// Wait for both the modules and source code to have finished loading</span><br><span class="line">dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0), ^&#123;</span><br><span class="line">RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">if (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">[strongSelf executeSourceCode:sourceCode sync:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，start方法在最后通过调用executeSourceCode:执行JS代码，executeSourceCode:源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)executeSourceCode:(NSData *)sourceCode sync:(BOOL)sync</span><br><span class="line">&#123;</span><br><span class="line">dispatch_block_t completion = ^&#123;</span><br><span class="line">// 在主线程上执行状态更新和通知，这样我们就不会遇到RCTRootView的时序问题</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter]</span><br><span class="line">postNotificationName:RCTJavaScriptDidLoadNotification</span><br><span class="line">object:self-&gt;_parentBridge userInfo:@&#123;@&quot;bridge&quot;: self&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 根据sync来选择执行JS的方式（同步、异步）</span><br><span class="line">if (sync) &#123;</span><br><span class="line">[self executeApplicationScriptSync:sourceCode url:self.bundleURL];</span><br><span class="line">completion();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self enqueueApplicationScript:sourceCode url:self.bundleURL onComplete:completion];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，代码主要做了两件事：</p>
<p>1.准备一个completion的block，在JS执行完成后回调</p>
<p>2.根据sync来选择是同步执行还是异步执行JS</p>
<p>通过看这两个函数的实现，不难发现，最终他们都是调用了同一个方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)executeApplicationScript:(NSData *)script</span><br><span class="line">url:(NSURL *)url</span><br><span class="line">async:(BOOL)async</span><br><span class="line">&#123;</span><br><span class="line">[self _tryAndHandleError:^&#123;</span><br><span class="line">NSString *sourceUrlStr = deriveSourceURL(url);</span><br><span class="line">// 发送 将要执行JS 的通知  RCTJavaScriptWillStartExecutingNotification</span><br><span class="line">[[NSNotificationCenter defaultCenter]</span><br><span class="line">postNotificationName:RCTJavaScriptWillStartExecutingNotification</span><br><span class="line">object:self-&gt;_parentBridge userInfo:@&#123;@&quot;bridge&quot;: self&#125;];</span><br><span class="line">// 如果是RAMBundle则调用_reactInstance的loadRAMBundle:方法</span><br><span class="line">// 否则调用_reactInstance的loadScriptFromString:方法</span><br><span class="line">if (isRAMBundle(script)) &#123;</span><br><span class="line">[self-&gt;_performanceLogger markStartForTag:RCTPLRAMBundleLoad];</span><br><span class="line">auto ramBundle = std::make_unique&lt;JSIndexedRAMBundle&gt;(sourceUrlStr.UTF8String);</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; scriptStr = ramBundle-&gt;getStartupCode();</span><br><span class="line">[self-&gt;_performanceLogger markStopForTag:RCTPLRAMBundleLoad];</span><br><span class="line">[self-&gt;_performanceLogger setValue:scriptStr-&gt;size() forTag:RCTPLRAMStartupCodeSize];</span><br><span class="line">if (self-&gt;_reactInstance) &#123;</span><br><span class="line">auto registry = RAMBundleRegistry::multipleBundlesRegistry(std::move(ramBundle), JSIndexedRAMBundle::buildFactory());</span><br><span class="line">self-&gt;_reactInstance-&gt;loadRAMBundle(std::move(registry), std::move(scriptStr),</span><br><span class="line">sourceUrlStr.UTF8String, !async);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (self-&gt;_reactInstance) &#123;</span><br><span class="line">self-&gt;_reactInstance-&gt;loadScriptFromString(std::make_unique&lt;NSDataBigString&gt;(script),</span><br><span class="line">sourceUrlStr.UTF8String, !async);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">std::string methodName = async ? &quot;loadApplicationScript&quot; : &quot;loadApplicationScriptSync&quot;;</span><br><span class="line">throw std::logic_error(&quot;Attempt to call &quot; + methodName + &quot;: on uninitialized bridge&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如我在以上源码中加的注释所述，这个方法做了2件事：</p>
<p>1.发送一个将要执行JS的通知 名为RCTJavaScriptWillStartExecutingNotification</p>
<p>2.根据bundle的类型（是否为RAMBundle）分别调用_reactInstance的不同方法。如果是RAMBundle则调用_reactInstance的loadRAMBundle:方法，否则调用_reactInstance的loadScriptFromString:方法。因篇幅问题，因篇幅问题，此处不对RAM bundle展开介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Instance.cpp</span><br><span class="line"></span><br><span class="line">// load普通的 JS bundle</span><br><span class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">std::string sourceURL,</span><br><span class="line">bool loadSynchronously) &#123;</span><br><span class="line">if (loadSynchronously) &#123;</span><br><span class="line">loadApplicationSync(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">loadApplication(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// load RAM bundle</span><br><span class="line">void Instance::loadRAMBundle(std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; startupScript,</span><br><span class="line">std::string startupScriptSourceURL,</span><br><span class="line">bool loadSynchronously) &#123;</span><br><span class="line">if (loadSynchronously) &#123;</span><br><span class="line">loadApplicationSync(std::move(bundleRegistry), std::move(startupScript),</span><br><span class="line">std::move(startupScriptSourceURL));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">loadApplication(std::move(bundleRegistry), std::move(startupScript),</span><br><span class="line">std::move(startupScriptSourceURL));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们发现无论是加载RAM bundle还是加载普通的bundle都调用了Instance的loadApplicationSync或loadApplication方法。下面我们来看这两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Instance.cpp </span><br><span class="line"></span><br><span class="line">void Instance::loadApplication(std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">std::string sourceURL) &#123;</span><br><span class="line">nativeToJsBridge_-&gt;loadApplication(std::move(bundleRegistry), std::move(string),</span><br><span class="line">std::move(sourceURL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Instance::loadApplicationSync(std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">std::string sourceURL) &#123;</span><br><span class="line">nativeToJsBridge_-&gt;loadApplicationSync(std::move(bundleRegistry), std::move(string),</span><br><span class="line">std::move(sourceURL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们发现，Instance执行JS的方法又调用到了nativeToJsBridge这一层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// NativeToJsBridge.cpp </span><br><span class="line"></span><br><span class="line">void NativeToJsBridge::loadApplication(</span><br><span class="line">std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; startupScript,</span><br><span class="line">std::string startupScriptSourceURL) &#123;</span><br><span class="line"></span><br><span class="line">runOnExecutorQueue(</span><br><span class="line">[this,</span><br><span class="line">bundleRegistryWrap=folly::makeMoveWrapper(std::move(bundleRegistry)),</span><br><span class="line">startupScript=folly::makeMoveWrapper(std::move(startupScript)),</span><br><span class="line">startupScriptSourceURL=std::move(startupScriptSourceURL)]</span><br><span class="line">(JSExecutor* executor) mutable &#123;</span><br><span class="line">auto bundleRegistry = bundleRegistryWrap.move();</span><br><span class="line">// 如果是RAM bundle则把 bundle 传给 executor</span><br><span class="line">if (bundleRegistry) &#123;</span><br><span class="line">executor-&gt;setBundleRegistry(std::move(bundleRegistry));</span><br><span class="line">&#125;</span><br><span class="line">// 调用JSIExecutor加载脚本</span><br><span class="line">try &#123;</span><br><span class="line">executor-&gt;loadApplicationScript(std::move(*startupScript),</span><br><span class="line">std::move(startupScriptSourceURL));</span><br><span class="line">&#125; catch (...) &#123;</span><br><span class="line">m_applicationScriptHasFailure = true;</span><br><span class="line">throw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NativeToJsBridge::loadApplicationSync(</span><br><span class="line">std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; startupScript,</span><br><span class="line">std::string startupScriptSourceURL) &#123;</span><br><span class="line">if (bundleRegistry) &#123;</span><br><span class="line">m_executor-&gt;setBundleRegistry(std::move(bundleRegistry));</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">m_executor-&gt;loadApplicationScript(std::move(startupScript),</span><br><span class="line">std::move(startupScriptSourceURL));</span><br><span class="line">&#125; catch (...) &#123;</span><br><span class="line">m_applicationScriptHasFailure = true;</span><br><span class="line">throw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，loadApplication和loadApplicationSync这两个方法实现基本一致，都是调用了成员变量m_executor的loadApplicationScript方法，区别在于loadApplication把代码放到了m_executorMessageQueueThread中去执行，而loadApplicationSync在当前线程执行。让我们来看下JSIExecutor（生产环境）的loadApplicationScript的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// JSIexecutor.cpp</span><br><span class="line"></span><br><span class="line">void JSIExecutor::loadApplicationScript(</span><br><span class="line">std::unique_ptr&lt;const JSBigString&gt; script,</span><br><span class="line">std::string sourceURL) &#123;</span><br><span class="line"></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">*runtime_,</span><br><span class="line">&quot;nativeModuleProxy&quot;,</span><br><span class="line">Object::createFromHostObject(</span><br><span class="line">*runtime_, std::make_shared&lt;NativeModuleProxy&gt;(*this)));</span><br><span class="line"></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">*runtime_,</span><br><span class="line">&quot;nativeFlushQueueImmediate&quot;,</span><br><span class="line">Function::createFromHostFunction(</span><br><span class="line">*runtime_,</span><br><span class="line">PropNameID::forAscii(*runtime_, &quot;nativeFlushQueueImmediate&quot;),</span><br><span class="line">1,</span><br><span class="line">[this](</span><br><span class="line">jsi::Runtime &amp;,</span><br><span class="line">const jsi::Value &amp;,</span><br><span class="line">const jsi::Value *args,</span><br><span class="line">size_t count) &#123;</span><br><span class="line">callNativeModules(args[0], false);</span><br><span class="line">return Value::undefined();</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">*runtime_,</span><br><span class="line">&quot;nativeCallSyncHook&quot;,</span><br><span class="line">Function::createFromHostFunction(</span><br><span class="line">*runtime_,</span><br><span class="line">PropNameID::forAscii(*runtime_, &quot;nativeCallSyncHook&quot;),</span><br><span class="line">1,</span><br><span class="line">[this](</span><br><span class="line">jsi::Runtime &amp;,</span><br><span class="line">const jsi::Value &amp;,</span><br><span class="line">const jsi::Value *args,</span><br><span class="line">size_t count) &#123; return nativeCallSyncHook(args, count); &#125;));</span><br><span class="line">// 最终调用到JavaScriptCore的JSEvaluateScript函数</span><br><span class="line">runtime_-&gt;evaluateJavaScript(</span><br><span class="line">std::make_unique&lt;BigStringBuffer&gt;(std::move(script)), sourceURL);</span><br><span class="line"></span><br><span class="line">flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，loadApplicationScript方法主要做了3件事：</p>
<p>1.将Native侧的NativeModuleProxy对象注入到global的nativeModuleProxy上，相当于global.nativeModuleProxy = new NativeModuleProxy。</p>
<p>2.然后向global中注入了nativeFlushQueueImmediate，nativeCallSyncHook 2个方法。相当于global.nativeFlushQueueImmediate = JSIExecutor::callNativeModules(args); global.nativeCallSyncHook = JSIExecutor::nativeCallSyncHook(args)；注入成功后，JS侧的global调用nativeFlushQueueImmediate或nativeCallSyncHook这两个方法就会直接调用到JSIExecutor对应的方法上。</p>
<p>3.调用runtime_-&gt;evaluateJavaScript方法，最终调用到JavaScriptCore的JSEvaluateScript函数。对JavaScriptCore了解的开发者应该都知道JSEvaluateScript的作用就是在JS环境中执行JS代码。</p>
<p>4.JS脚本执行完成，执行flush操作。flush函数的主要作用就是执行JS侧的队列中缓存的对native的方法调用。</p>
<h3 id="evaluateJavaScript"><a href="#evaluateJavaScript" class="headerlink" title="evaluateJavaScript"></a>evaluateJavaScript</h3><p>上面说runtime最终调用到了JavaScriptCore的JSEvaluateScript函数。让我们再来看下JSCRuntime的evaluateJavaScript实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// JSCRumtime.cpp</span><br><span class="line"></span><br><span class="line">jsi::Value JSCRuntime::evaluateJavaScript(</span><br><span class="line">const std::shared_ptr&lt;const jsi::Buffer&gt; &amp;buffer,</span><br><span class="line">const std::string&amp; sourceURL) &#123;</span><br><span class="line">std::string tmp(</span><br><span class="line">reinterpret_cast&lt;const char*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">JSStringRef sourceURLRef = nullptr;</span><br><span class="line">if (!sourceURL.empty()) &#123;</span><br><span class="line">sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">&#125;</span><br><span class="line">JSValueRef exc = nullptr;</span><br><span class="line">JSValueRef res =</span><br><span class="line">JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, 0, &amp;exc);</span><br><span class="line"></span><br><span class="line">return createValue(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，最终还是调用的JavaScriptCore的JSEvaluateScript这个函数来执行JS代码。对JavaScriptCore或Hybrid开发有了解的人应该对这个函数非常熟悉，这个函数最关键的是前两个参数ctx和script，分别代表JS执行环境和将要执行的脚本字符串。</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>在ctx中执行JS源码，会初始化JS环境，BatchedBridge.js,NativeModules.js中的初始化代码也会执行。在BatchedBridge.js中，创建了一个名为BatchedBridge的MessageQueue，并设置到global的__fbBatchedBridge属性里，这个属性后面会用到。在初始化JS环境的时候，会加载到某些NativeModule，这些module才会被初始化，即调用到native侧JSINativeModules的getModule方法。当相关的Module都加载完之后，evaluateScript方法执行完，JS环境初始化完毕。然后就到执行flush方法。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// JSIExecutor.cpp</span><br><span class="line"></span><br><span class="line">void JSIExecutor::flush() &#123;</span><br><span class="line">if (flushedQueue_) &#123;</span><br><span class="line">callNativeModules(flushedQueue_-&gt;call(*runtime_), true);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Value batchedBridge =</span><br><span class="line">runtime_-&gt;global().getProperty(*runtime_, &quot;__fbBatchedBridge&quot;);</span><br><span class="line">if (!batchedBridge.isUndefined()) &#123;</span><br><span class="line">bindBridge();</span><br><span class="line">callNativeModules(flushedQueue_-&gt;call(*runtime_), true);</span><br><span class="line">&#125; else if (delegate_) &#123;</span><br><span class="line">callNativeModules(nullptr, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑是：</p>
<p>1.如果JSIExecutor的flushedQueue_函数不为空，则通过函数flushedQueue_获取待调用的方法queue，然后执行callNativeModules。（第一次调用flush()时，flushedQueue_必为空，稍后在bindBridge()中才bind flushedQueue_）</p>
<p>2.以”__fbBatchedBridge”作为属性key去global中取对应的值也就是batchedBridge，batchedBridge本质上是JS侧的MessageQueue类实例化的一个对象</p>
<p>3.如果获取到了JS侧定义的batchedBridge对象，则执行bindBridge操作（我们知道在JS初始化环境的时候，JS的batchedBridge这个值已经被初始化为MessageQueue对象，在BatchedBridge.js中，创建了一个名为BatchedBridge的MessageQueue对象，并设置到global的__fbBatchedBridge属性里），即把batchedBridge中的方法和Native侧JSIExecutor的方法进行绑定。这些bind操作本质上是native指针指向JS函数。例如：把batchedBridge中的callFunctionReturnFlushedQueue 和 JSIExecutor对象的callFunctionReturnFlushedQueue_进行绑定；把batchedBridge中的invokeCallbackAndReturnFlushedQueue 和 JSIExecutor中的invokeCallbackAndReturnFlushedQueue_进行绑定；把batchedBridge中的flushedQueue 和 JSIExecutor中的flushedQueue_进行绑定。把batchedBridge中的callFunctionReturnResultAndFlushedQueue 和 JSIExecutor中的callFunctionReturnResultAndFlushedQueue_进行绑定。bind完成之后，执行callNativeModules方法。</p>
<p>4.如果没有获取到JS侧定义的batchedBridge对象，则直接执行callNativeModules方法，即没有bind操作。</p>
<p>让我们继续看bindBridge方法的实现吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// JSIExecutor.cpp</span><br><span class="line"></span><br><span class="line">void JSIExecutor::bindBridge() &#123;</span><br><span class="line">std::call_once(bindFlag_, [this] &#123;</span><br><span class="line">Value batchedBridgeValue =</span><br><span class="line">runtime_-&gt;global().getProperty(*runtime_, &quot;__fbBatchedBridge&quot;);</span><br><span class="line"></span><br><span class="line">Object batchedBridge = batchedBridgeValue.asObject(*runtime_);</span><br><span class="line">callFunctionReturnFlushedQueue_ = batchedBridge.getPropertyAsFunction(</span><br><span class="line">*runtime_, &quot;callFunctionReturnFlushedQueue&quot;);</span><br><span class="line">invokeCallbackAndReturnFlushedQueue_ = batchedBridge.getPropertyAsFunction(</span><br><span class="line">*runtime_, &quot;invokeCallbackAndReturnFlushedQueue&quot;);</span><br><span class="line">flushedQueue_ =</span><br><span class="line">batchedBridge.getPropertyAsFunction(*runtime_, &quot;flushedQueue&quot;);</span><br><span class="line">callFunctionReturnResultAndFlushedQueue_ =</span><br><span class="line">batchedBridge.getPropertyAsFunction(</span><br><span class="line">*runtime_, &quot;callFunctionReturnResultAndFlushedQueue&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bindBridge把global中的函数变量赋值给了JSIExecutor的成员变量指针，这为后面Native call JS做好了准备。</p>
<h1 id="Native调用JS"><a href="#Native调用JS" class="headerlink" title="Native调用JS"></a>Native调用JS</h1><p>上面说了bindBridge方法中把global.batchedBridge中的方法和Native侧JSIExecutor的方法进行绑定。本质上就是Native指针指向JS函数（例如：JSIExecutor::callFunctionReturnFlushedQueue_ = global.batchedBridge.callFunctionReturnFlushedQueue）。这样就可以在native侧直接调用到JS函数，实现native调用JS。本节将从源码的角度介绍Native调用JS的相关细节。</p>
<p>执行完JS源码完成后，在RCTCxxBridge中会发送一个名为RCTJavaScriptDidLoadNotification的通知。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// RCTCxxBridge.mm</span><br><span class="line"></span><br><span class="line">- (void)executeSourceCode:(NSData *)sourceCode sync:(BOOL)sync</span><br><span class="line">&#123;</span><br><span class="line">// 可以在任何执行JS的线程调用</span><br><span class="line">dispatch_block_t completion = ^&#123;</span><br><span class="line">// 在主线程上执行状态更新和通知，这样我们就不会遇到RCTRootView的时序问题</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">// 主线程发送一个通知</span><br><span class="line">[[NSNotificationCenter defaultCenter]</span><br><span class="line">postNotificationName:RCTJavaScriptDidLoadNotification</span><br><span class="line">object:self-&gt;_parentBridge userInfo:@&#123;@&quot;bridge&quot;: self&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if (sync) &#123;</span><br><span class="line">[self executeApplicationScriptSync:sourceCode url:self.bundleURL];</span><br><span class="line">completion();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self enqueueApplicationScript:sourceCode url:self.bundleURL onComplete:completion];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RCTRootView监听到这个通知后执行了javaScriptDidLoad:方法，然后沿着Instance-&gt;NativeToJsBridge-&gt;JSIExecutor这个调用链调用了JSIExecutor::callFunction方法，方法内调用了JSIExecutor的callFunctionReturnFlushedQueue_方法，bindBridge一节中介绍了callFunctionReturnFlushedQueue_是通过runtime将native指针指向JS函数。所以，就相当于调用JS MessageQueue的callFunctionReturnFlushedQueue方法，该方法接收调用JS方法所需的moduleId、methodId和参数，执行完毕后JS会给Native返回一个queue，该queue中是一系列JS需要native侧执行的方法。最后这个queue被交给callNativeModules进行调用。详细调用过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">// RCTRootView.m</span><br><span class="line"></span><br><span class="line">- (void)javaScriptDidLoad:(NSNotification *)notification</span><br><span class="line">&#123;</span><br><span class="line">RCTBridge *bridge = notification.userInfo[@&quot;bridge&quot;];</span><br><span class="line">if (bridge != _contentView.bridge) &#123;</span><br><span class="line">[self bundleFinishedLoading:bridge];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)bundleFinishedLoading:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">_contentView = [[RCTRootContentView alloc] initWithFrame:self.bounds</span><br><span class="line">bridge:bridge</span><br><span class="line">reactTag:self.reactTag</span><br><span class="line">sizeFlexiblity:_sizeFlexibility];</span><br><span class="line">[self runApplication:bridge];</span><br><span class="line">[self insertSubview:_contentView atIndex:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)runApplication:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">NSString *moduleName = _moduleName ?: @&quot;&quot;;</span><br><span class="line">NSDictionary *appParameters = @&#123;</span><br><span class="line">@&quot;rootTag&quot;: _contentView.reactTag,</span><br><span class="line">@&quot;initialProps&quot;: _appProperties ?: @&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">// 调用RCTCxxBridge的enqueueJSCall:method:args:completion:方法</span><br><span class="line">[bridge enqueueJSCall:@&quot;AppRegistry&quot;</span><br><span class="line">method:@&quot;runApplication&quot;</span><br><span class="line">args:@[moduleName, appParameters]</span><br><span class="line">completion:NULL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NativeToJsBridge.cpp</span><br><span class="line">// 该方法可以在任何线程调用</span><br><span class="line">- (void)enqueueJSCall:(NSString *)module method:(NSString *)method args:(NSArray *)args completion:(dispatch_block_t)completion</span><br><span class="line">&#123;</span><br><span class="line">__weak __typeof(self) weakSelf = self;</span><br><span class="line">[self _runAfterLoad:^()&#123;</span><br><span class="line">__strong __typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">if (strongSelf-&gt;_reactInstance) &#123;</span><br><span class="line">// 调用Instance的callJSFunction方法</span><br><span class="line">strongSelf-&gt;_reactInstance-&gt;callJSFunction([module UTF8String], [method UTF8String],</span><br><span class="line">convertIdToFollyDynamic(args ?: @[]));</span><br><span class="line"></span><br><span class="line">// ensureOnJavaScriptThread may execute immediately, so use jsMessageThread, to make sure</span><br><span class="line">// the block is invoked after callJSFunction</span><br><span class="line">if (completion) &#123;</span><br><span class="line">if (strongSelf-&gt;_jsMessageThread) &#123;</span><br><span class="line">strongSelf-&gt;_jsMessageThread-&gt;runOnQueue(completion);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RCTLogWarn(@&quot;Can&apos;t invoke completion without messageThread&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Instance.cpp</span><br><span class="line">void Instance::callJSFunction(std::string &amp;&amp;module, std::string &amp;&amp;method,</span><br><span class="line">folly::dynamic &amp;&amp;params) &#123;</span><br><span class="line">callback_-&gt;incrementPendingJSCalls();</span><br><span class="line">// 调用NativeToJSBridge的callFunction方法</span><br><span class="line">nativeToJsBridge_-&gt;callFunction(std::move(module), std::move(method),</span><br><span class="line">std::move(params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NativeToJsBridge.cpp</span><br><span class="line">void NativeToJsBridge::callFunction(</span><br><span class="line">std::string&amp;&amp; module,</span><br><span class="line">std::string&amp;&amp; method,</span><br><span class="line">folly::dynamic&amp;&amp; arguments) &#123;</span><br><span class="line">runOnExecutorQueue([this, module = std::move(module), method = std::move(method), arguments = std::move(arguments), systraceCookie]</span><br><span class="line">(JSExecutor* executor) &#123;</span><br><span class="line">// 调用JSIExecutor的callFunction方法</span><br><span class="line">executor-&gt;callFunction(module, method, arguments);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSIExecutor.cpp</span><br><span class="line">void JSIExecutor::callFunction(</span><br><span class="line">const std::string &amp;moduleId,</span><br><span class="line">const std::string &amp;methodId,</span><br><span class="line">const folly::dynamic &amp;arguments) &#123;</span><br><span class="line"></span><br><span class="line">Value ret = Value::undefined();</span><br><span class="line">try &#123;</span><br><span class="line">scopedTimeoutInvoker_(</span><br><span class="line">[&amp;] &#123;</span><br><span class="line">// 调用callFunctionReturnFlushedQueue_并把JS需要Native侧执行的方法queue作为返回值返回，赋值给ret</span><br><span class="line">// 传入JS moduleId、methodId、arguements</span><br><span class="line">// 返回值 queue</span><br><span class="line">ret = callFunctionReturnFlushedQueue_-&gt;call(</span><br><span class="line">*runtime_,</span><br><span class="line">moduleId,</span><br><span class="line">methodId,</span><br><span class="line">valueFromDynamic(*runtime_, arguments));</span><br><span class="line">&#125;,</span><br><span class="line">std::move(errorProducer));</span><br><span class="line">&#125; catch (...) &#123;</span><br><span class="line">std::throw_with_nested(</span><br><span class="line">std::runtime_error(&quot;Error calling &quot; + moduleId + &quot;.&quot; + methodId));</span><br><span class="line">&#125;</span><br><span class="line">// native侧刷新queue中需要执行的方法</span><br><span class="line">callNativeModules(ret, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面介绍了通过MessageQueue的callFunctionReturnFlushedQueue实现Native调用JS。除此之外还有其他3个与Native call JS相关的函数，我们已经在bindBridge中见过了。他们分别是：invokeCallbackAndReturnFlushedQueue、flushedQueue、callFunctionReturnResultAndFlushedQueue。看名字就知道他们的作用，这里不做详细介绍。 接下来JS的MessageQueue.js对callFunctionReturnFlushedQueue的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// MessageQueue.js</span><br><span class="line"></span><br><span class="line">callFunctionReturnFlushedQueue(module: string, method: string, args: any[]) &#123;</span><br><span class="line">this.__guard(() =&gt; &#123;</span><br><span class="line">this.__callFunction(module, method, args);</span><br><span class="line">&#125;);</span><br><span class="line">return this.flushedQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__callFunction(module: string, method: string, args: any[]): any &#123;</span><br><span class="line">const moduleMethods = this.getCallableModule(module);</span><br><span class="line">const result = moduleMethods[method].apply(moduleMethods, args);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flushedQueue() &#123;</span><br><span class="line">this.__guard(() =&gt; &#123;</span><br><span class="line">this.__callImmediates();</span><br><span class="line">&#125;);</span><br><span class="line">const queue = this._queue;</span><br><span class="line">this._queue = [[], [], [], this._callID];</span><br><span class="line">return queue[0].length ? queue : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出callFunctionReturnFlushedQueue主要做了两件事：</p>
<p>1.通过moduleId和methodId完成方法的调用（__callFunction函数）</p>
<p>2.返回一个queue（flushedQueue函数）</p>
<p>至此，Native调用JS相关的实现基本介绍完了。让我们总结下：</p>
<p>JS代码执行JS上下文环境都已经初始化，MessagQueue相关代码也会被调用，然后会通过runtime让Native指针指向JS函数，后面Native call JS都是通过这4个函数完成的。JS代码执行完毕后，RCTCxxBridge会发送一个名为RCTJavaScriptDidLoadNotification的通知给RCTRootView。然后经过RCTRootView-&gt;RCTBridge-&gt;RCTCxxBridge-&gt;Instance-&gt;NativeToJsBridge-&gt;JSIExecutor层层调用，最终通过调用callFunctionReturnFlushedQueue完成Native对JS的调用。Native call JS的四个核心函数如下，至此Native call JS基本介绍完了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flushedQueue</span><br><span class="line">callFunctionReturnFlushedQueue</span><br><span class="line">invokeCallbackAndReturnFlushedQueue</span><br><span class="line">callFunctionReturnResultAndFlushedQueue</span><br></pre></td></tr></table></figure>

<h1 id="JS调用Native"><a href="#JS调用Native" class="headerlink" title="JS调用Native"></a>JS调用Native</h1><p>前面说过，JS中global.__fbGenNativeModule属性其实就是NativeModules.js中定义的genModule函数。在加载JS脚本的时候，将JSINativeModule的m_genNativeModuleJS指向了global.__fbGenNativeModule。即<strong>global.__fbGenNativeModule == genModule == m_genNativeModuleJS</strong>。在执行JS源码时候，最终会调用到JSIExecutor::loadApplicationScript方法。这个方法中初始化了一个nativeModuleProxy对象并设置给了global.nativeModuleProxy。初始化nativeModuleProxy对象会触发nativeModuleProxy的get方法，get方法最终调用到JSINativeModules的createModule方法，createModule中调用了m_genNativeModuleJS方法即JS侧genModule函数，方法入参是native侧的ModuleConfig对象，返回值是moduleInfo（形如：{modulename, moduleInfo}，moduleName是模块名，moduleInfo是这个模块信息，包括模块方法）。JS侧拿到这个返回值进行缓存，后续通过缓存的这个moduleInfo获取native侧的模块配置，进而调用native方法，例如NativeModule.moduleName.methodName。</p>
<p>需要说明的是，通常情况下，JS是不会“直接的”调用OC方法的。当我们在JS中通过NativeModule调用native方法时，模块ID和方法ID会被加入一个名为_queue的队列，等到native侧调用JS方法时，顺便把这个队列作为返回值返回给native侧。Native侧再一一解析队列中的每一个moduleID和methodID后，封装成NSInvocation完成调用。如下是JS调用Native的流程图：</p>
<p><img src="/2020/03/04/详解ReactNative初始化和通信机制/JScallNative%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.png" alt="JS call Native 流程解析"></p>
<p>我们知道MessageQueue.js承接了Native和JS通信的任务。在Native调用JS一节中我们知道了callFunctionReturnFlushedQueue这个函数用于Native call JS，并把JS中的queue返回给Native。这个queue存储了一系列JS对Native的调用。native侧拿到这个queue后，就会解析这个queue中的内容，得到相关模块的配置和参数，并进行动态调用。iOS上的调用主要是把这些配置和参数封装NSInvocation实例，进行调用。其调用顺序大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// JSIExecutor.app</span><br><span class="line">void JSIExecutor::callNativeModules(const Value &amp;queue, bool isEndOfBatch) &#123;</span><br><span class="line">// delegate_是JsToNativeBridge类型的实例</span><br><span class="line">delegate_-&gt;callNativeModules(</span><br><span class="line">*this, dynamicFromValue(*runtime_, queue), isEndOfBatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JsToNativeBridge.cpp</span><br><span class="line">void callNativeModules(</span><br><span class="line">__unused JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, bool isEndOfBatch) override &#123;</span><br><span class="line"></span><br><span class="line">for (auto&amp; call : parseMethodCalls(std::move(calls))) &#123;</span><br><span class="line">m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, std::move(call.arguments), call.callId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ModuleRegistry.cpp</span><br><span class="line">void ModuleRegistry::callNativeMethod(unsigned int moduleId, unsigned int methodId, folly::dynamic&amp;&amp; params, int callId) &#123;</span><br><span class="line">modules_[moduleId]-&gt;invoke(methodId, std::move(params), callId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RCTNativeModule.mm</span><br><span class="line">void RCTNativeModule::invoke(unsigned int methodId, folly::dynamic &amp;&amp;params, int callId) &#123;</span><br><span class="line">__weak RCTBridge *weakBridge = m_bridge;</span><br><span class="line">__weak RCTModuleData *weakModuleData = m_moduleData;</span><br><span class="line"></span><br><span class="line">invokeInner(weakBridge, weakModuleData, methodId, std::move(params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RCTNativeModule.mm</span><br><span class="line">static MethodCallResult invokeInner(RCTBridge *bridge, RCTModuleData *moduleData, unsigned int methodId, const folly::dynamic &amp;params) &#123;</span><br><span class="line">id&lt;RCTBridgeMethod&gt; method = moduleData.methods[methodId];</span><br><span class="line">NSArray *objcParams = convertFollyDynamicToId(params);</span><br><span class="line">id result = [method invokeWithBridge:bridge module:moduleData.instance arguments:objcParams];</span><br><span class="line">return convertIdToFollyDynamic(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RCTModuleMethod.mm</span><br><span class="line">- (id)invokeWithBridge:(RCTBridge *)bridge</span><br><span class="line">module:(id)module</span><br><span class="line">arguments:(NSArray *)arguments</span><br><span class="line">&#123;</span><br><span class="line">[_invocation invokeWithTarget:module]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，是JS call Native 的方法调用链，主要是JSIExecutor先收到JS侧的调用请求，然后将请求转发给JSIExecutor实例的m_delegate，也就是调用m_delegate的callNativeModules方法，m_delegate本质上就是一个JSToNativeBridge实例，他是在NativeToJSBridge的初始化列表中初始化JSIExecutor时传给JSIExecutor的。m_delegate继续调用m_registry的callNativeMethod方法，m_registry是m_delegate的一个成员变量，也就是JSToNativeBridge的成员变量。然后调用经由NativeModule和RCTBridgeMethod转发，最后在RCTBridgeMethod中通过NSInvocation的方式完成了native侧方法的调用。</p>
<p>至此，JS调用Native方法就介绍完了。</p>
<h2 id="三个疑问"><a href="#三个疑问" class="headerlink" title="三个疑问"></a>三个疑问</h2><p>你可能有3个疑问：</p>
<p>1.为什么JS不同步调用native方法而选择异步？</p>
<p>2.为什么RN不主动调用JS而是把调用缓存到队列，而是等native call JS时再把队列以返回值的形式返回给native？这样JS还能跑的通吗？</p>
<p>3.设计成这样如何保证native侧的方法可以得到及时的调用？</p>
<p>对于第一个问题：我们知道JS代码是运行在JS线程而非main thread，并且JS是单线程，如果同步调用native方法就会block住JS代码的运行，所以RN选择了JS和Native异步通信。</p>
<p>对于第二个问题：JS不会主动传递数据给OC，在调OC方法时，会把ModuleID，MethodID等数据加到一个队列里，等OC过来调JS的任意方法时，再把这个队列返回给OC，此时OC再执行这个队列里要调用的方法。让我们回顾下iOS的事件传递和响应机制就会恍然大悟，在Native开发中，只在有事件触发的时候，才会调用native代码。这个事件可以是启动事件、触摸事件、滚动事件、timer事件、系统事件、回调事件。而在React Native里，本质上JSX Component最终都是native view。这些事件发生时OC都会调用JS侧相应的方法以保证JS侧和native侧保持同步，JS处理完这些事件后再执行JS想让OC执行的方法，而没有事件发生的时候，是不会执行任何代码的，这跟native开发里事件响应机制是一致的。在native调用JS的时候，JS把需要native处理的方法队列返回给native侧让native去处理。这样既保证了JS和native侧事件和逻辑的同步，JS也可以趁机搭车call native，避免了JS和native侧频繁的通信。 RN的这种设计还是很合理的，真的是巧夺天工，这种设计思路还是值得借鉴的。</p>
<p>对于第三个问题：JS只是被动的等待native call JS，然后趁机把队列返回给native，那么如何保证方法调用的及时性呢？换句话说，如果native迟迟不调用JS，那JS侧队列中一大堆方法旧只能干等着吗？答案当然不是这样的，JS规定了一个时间阈值，这阈值是5ms，如果超过5ms后依旧没有native call JS。那么JS就会主动触发队列的刷新，即立即让native侧执行队列中缓存的一系列的方法。JS侧触发native的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// MessageQueue.js</span><br><span class="line"></span><br><span class="line">const MIN_TIME_BETWEEN_FLUSHES_MS = 5;</span><br><span class="line"></span><br><span class="line">enqueueNativeCall(</span><br><span class="line">moduleID: number,</span><br><span class="line">methodID: number,</span><br><span class="line">params: any[],</span><br><span class="line">onFail: ?Function,</span><br><span class="line">onSucc: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">this.processCallbacks(moduleID, methodID, params, onFail, onSucc);</span><br><span class="line"></span><br><span class="line">this._queue[MODULE_IDS].push(moduleID);</span><br><span class="line">this._queue[METHOD_IDS].push(methodID);</span><br><span class="line">this._queue[PARAMS].push(params);</span><br><span class="line"></span><br><span class="line">const now = Date.now();</span><br><span class="line">if (</span><br><span class="line">global.nativeFlushQueueImmediate &amp;&amp;</span><br><span class="line">now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS</span><br><span class="line">) &#123;</span><br><span class="line">const queue = this._queue;</span><br><span class="line">this._queue = [[], [], [], this._callID];</span><br><span class="line">this._lastFlush = now;</span><br><span class="line">global.nativeFlushQueueImmediate(queue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，每次JS想要call native，都会判断距上一次flush queue的时间间隔，如果间隔大于或等于5ms，就调用global.nativeFlushQueueImmediate方法，把queue作为入参传给native。</p>
<h1 id="大结局"><a href="#大结局" class="headerlink" title="大结局"></a>大结局</h1><p>好了，虽然讲了很多，也很啰嗦，但事无巨细，尤其是对于RN这种庞大的工程框架，一篇文章是很难覆盖各个细节的。对于一些重要的细节，日后找机会写文章单独分析。最后总结一下RN的初始化启动流程：</p>
<p>RN的启动流程主要分4个阶段：bridge初始化阶段、源码加载阶段、源码执行阶段、运行JSApplication阶段</p>
<h2 id="bridge初始化阶段"><a href="#bridge初始化阶段" class="headerlink" title="bridge初始化阶段"></a>bridge初始化阶段</h2><p>bridge初始化阶段主要是初始化并配置了RCTBridge实例、RCTCxxBridge实例、Instance实例、NativeToJSBridge实例、JSIExecutor实例。</p>
<ol>
<li>在APPDelegate的启动方法中创建了RCTBridge和一个RCTRootView，然后在RCTBridge中创建了一个名为batchedBridge的RCTCxxBridge实例，并调用了self.batchedBridge start方法。在start方法里先创建了一个专门用来运行JS代码的JS线程，这个线程绑定到了一个runloop以免退出。然后将所有注册的module生成RCTModuleData，并根据需要调用他们的初始化方法，以上操作都是在main thread中进行的。</li>
<li>接下来一边在JS线程中执行Intance的初始化方法，一边异步进行JS源码的加载。Intance的初始化主要是在Instance::initializeBridge方法里创建了一个名为nativeToJsBridge_的NativeToJSBridge实例变量。然后NativeToJsBridge的初始化方法里通过executorFactory创建了一个名为m_executor的JSIExecutor实例并传入了一个runtime变量。至此，Instance、NativeToJSBridge、JSIExecutor初始化完成。</li>
</ol>
<h2 id="源码加载阶段"><a href="#源码加载阶段" class="headerlink" title="源码加载阶段"></a>源码加载阶段</h2><p>start方法中初始化Instance的同时还在load JS源码，JS源码加载分为同步和异步。JS bundle类型分为RAM bundle和普通bundle。load完成后返回JS sourceCode进入源码执行阶段。</p>
<h2 id="源码执行阶段"><a href="#源码执行阶段" class="headerlink" title="源码执行阶段"></a>源码执行阶段</h2><p>当JS sourceCode加载完成且native module也初始化也完成后，就会继续走执行JS源码的逻辑，主要是初始化JS上下文环境，并建立Native call JS的能力，即Native指针指向JS函数。</p>
<ol>
<li>start方法先是调用executeSourceCode方法，然后经过RCTCxxBridge -&gt; Instance -&gt; NativeToJsBridge -&gt; JSIExecutor层层调用最终会执行到JSIExecutor::loadApplicationScript方法。在JSIExecutor::loadApplicationScript中通过runtime向global中注入了nativeModuleProxy。并且将JSIExecutor::nativeFlushQueueImmediate、JSIExecutor::nativeCallSyncHook注入到global中。</li>
<li>向global注入nativeModuleProxy的时候，会触发nativeModuleProxy的get方法，目的是生成native module的配置信息并返回给JS。 主要逻辑是通过nativeModuleProxy -&gt; JSINativeModules.getModule -&gt; JSINativeModules.createModule层层调用，最后调用JS在global中注册的genModule这个方法把native module配置信息生成对应的JS对象，JS会缓存这个对象用于将来调用native。当然native侧早就有了一份module配置信息表，这个表存储在ModuleRegistry中。日后JS call Native 都是传递的模块ID和方法ID，然后native再根据ID去查表完成方法调用。</li>
<li>在JSIExecutor::loadApplicationScript中会调用JSCRumtime的evaluteJavaScript方法，进而调用到JavaScriptCore的JSEvaluateScript方法执行JS源码。</li>
<li>在JS源码执行完后，JSIExecutor::loadApplicationScript中会调用flush()方法刷新JS的messageQueue中缓存的方法队列。</li>
</ol>
<h2 id="运行JS-Application阶段"><a href="#运行JS-Application阶段" class="headerlink" title="运行JS Application阶段"></a>运行JS Application阶段</h2><p>上面JS脚本执行完后，RCTCxxBridge会发送一个名为RCTJavaScriptDidLoadNotification的通知给RCTRootView执行runApplication相关的逻辑。RCTRootView收到通知后会把运行JS所需的moduleName、methodName、appKey和页面所需的参数传给JS。moduleName通常是@”AppRegistry”，用于调用RN的名字为”AppRegistry”的组件。methodName通常是@”runApplication”，用于调用JS的AppRegistry.runApplication方法。appKey是页面的key，也是AppRegistry.runApplication的入参，用于唯一标识一个组件，本文中是@”NewProject”。参数很好理解了，就是初始化页面的一些业务参数。</p>
<ol>
<li>执行runApplication相关的逻辑链条：RCTRootView -&gt; RCTBridge-&gt;RCTCxxBridge-&gt;Instace-&gt;NativeToJsBridge-&gt;JSIExecutor。通过以上层层调用后，最终调用到JSIExecutor的callFunction方法，如果没有绑定JS和Native侧的方法则调用bindBridge执行bind逻辑，将MessageQueue.js中定义的4个方法绑定到JSIExecutor的成员变量上（相当于Native指针指向JS函数），这4个函数是flushQueue、callFunctionReturnFlushedQueue、invokeCallbackAndReturnFlushedQueue、callFunctionReturnResultAndFlushedQueue。关于bind这4个函数的逻辑在源码执行阶段已经讲过了。</li>
<li>然后调用callFunctionReturnFlushedQueue方法获取JS待native刷新的方法队列，把队列通过JSIExecutor::callNativeModules交给JSIExecutor的m_delegate进行处理。m_delegate是一个JSToNativeBridge的实例。专门负责处理JS call Native相关的逻辑。</li>
<li>第2步中调用callFunctionReturnFlushedQueue时会把@”AppRegistry”、@”runApplication”、appKey、arguments作为入参传递个JS，JS侧收到这个消息后，就调用了JS中的AppRegistry的runApplication方法。到这里，JS的入口就被调用，界面就会渲染出来。JS的入口如下：</li>
</ol>
<p>总结下来，React Native用iOS自带的JavaScriptCore作为JS的解析引擎，即JS和Native的相互通信是经过JavaScriptCore机制来进行的。但并没有用到JavaScriptCore提供的一些可以让JS与OC互调的特性，而是自己实现了一套机制，这套机制可以通用于所有JS引擎上。</p>
<p>在程序启动阶段会收集所有native暴露给JS的模块和方法。然后初始化阶段会创建并配置JS相关的桥。在执行JS源码阶段，Native的JSIExecutor会注入nativeModuleProxy和两个方法到JS全局变量global中，相当于JS指针指向Native变量，这样就建立了JS调用Native的能力。注入到global中的两个方法是nativeFlushQueueImmediate和nativeCallSyncHook，将来JS侧调用这两个方法就会走到Native侧的方法实现中。</p>
<p>但是JS call Native并不直接调用Native的方法，而且先放入一个JS队列中，每次Native call JS时JS都会将这个队列返回给Native，Native拿到这个队列后根据队列中的moduleID、methodID和方法参数等信息生成NSInvocation，完成Native的方法调用。这种实现方式避免了JS和Native的频繁通信。</p>
<p>JS脚本加载并执行完成后native会调用JS，告诉JS可以runApplication了，接下页面救护被渲染出来。<br>至此，全篇完！</p>
<p>文／VV木公子（简书作者）<br><strong>PS:如非特别说明，所有文章均为原创作品，著作权归作者所有，转载请联系作者获得授权，并注明出处。</strong></p>
<p>如果您是iOS开发者，或者对本篇文章感兴趣，请关注本人，后续会更新更多相关文章！敬请期待！</p>

        
    </section>
</article>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "wsv587.github.io",
        owner: "wsv587",
        admin: ["wsv587"],
        id: "2020/03/04/详解ReactNative初始化和通信机制",
        distractionFreeMode: true,
        title: "详解ReactNative初始化和通信机制",
        body: "http://yoursite.com/2020/03/04/详解ReactNative初始化和通信机制/",
        labels: ["iOS","ReactNative"]
    }).render('comments');
    </script>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script>
    

</body>
</html>
